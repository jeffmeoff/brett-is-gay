<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BrettIsGay.com</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Gochi+Hand&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* A neutral background for the whole app */
            overflow: hidden; /* Prevent scrolling on the body */
            touch-action: none;
        }
        #app-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 4rem; /* Height of the nav bar */
            overflow: hidden;
        }
        .page {
            display: none; /* Hide pages by default */
            width: 100%;
            height: 100%;
            overflow-y: auto;
        }
        .page.active {
            display: block; /* Show active page */
        }

        /* Transition Screen */
        #transition-screen {
            transition: opacity 1s ease-in-out;
        }


        /* Feed Page Styles */
        #feed-page {
             background-color: #f5f3ef;
             background-image: url('https://www.transparenttextures.com/patterns/light-paper-fibers.png');
        }
        .post-card {
            background-color: white;
            padding: 1rem;
            padding-bottom: 3.5rem; /* Space for caption */
            border-radius: 0.25rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            position: relative;
            break-inside: avoid;
            margin-bottom: 1.5rem;
        }
        .post-card img {
            width: 100%;
            height: auto;
            border: 1px solid #eee;
        }
        .post-card .caption {
            font-family: 'Gochi Hand', cursive;
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            text-align: center;
            font-size: 1.25rem;
            color: #333;
        }
        
        #feed-container {
            column-count: 2;
            column-gap: 1.5rem;
        }
        @media (max-width: 640px) {
            #feed-container {
                column-count: 1;
            }
        }

        .animate-fadeIn { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .modal { display: none; }
        .modal.active { display: flex; }
        .modal { z-index: 50; }

        /* Game Page Styles */
        #games-page {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            position: relative;
        }
        .game-container { display: none; }
        .game-container.active { display: flex; }
        #game-selection-menu {
            position: relative;
            z-index: 10;
        }
        #matrix-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #matrix-canvas.fullscreen {
            z-index: 20;
        }

        /* Breakout Game Styles */
        #breakout-game-container {
            font-family: 'Press Start 2P', cursive;
            color: #FFFFFF;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #game-wrapper { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        #game-container { border: 4px solid #00FFFF; border-radius: 10px; box-shadow: 0 0 20px #FF00FF, inset 0 0 20px #FF00FF; position: relative; width: 100%; height: 100%; max-width: 480px; max-height: 800px; }
        #breakoutCanvas { background-color: #000; display: block; width: 100%; height: 100%; cursor: pointer; }
        #ui-overlay { position: absolute; top: 15px; left: 20px; right: 20px; display: flex; justify-content: space-between; color: #fff; font-size: clamp(12px, 3vw, 1rem); pointer-events: none; text-shadow: 2px 2px 4px #FF00FF; }
        #modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 10px; border: 4px solid #00FFFF; text-align: center; z-index: 100; width: 80%; display: none; }
        #modal h2 { font-size: clamp(1.5em, 5vw, 2em); margin-bottom: 10px; color: #FFFF00; }
        #modal p { font-size: clamp(0.8em, 3vw, 1em); margin-bottom: 20px; color: #00FFFF; }
        #modal button { background-color: #FF00FF; color: white; padding: 15px 25px; border: 2px solid white; border-radius: 5px; font-family: 'Press Start 2P', cursive; cursor: pointer; font-size: clamp(0.8em, 4vw, 1em); box-shadow: 0 0 10px #fff; }

        /* Connect Four Game Styles */
        #connect-four-container {
            font-family: 'Poppins', sans-serif;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 1rem;
            background-color: #f3f4f6; /* gray-100 */
        }
        #board-container { position: relative; width: 100%; max-width: 560px; aspect-ratio: 7 / 6; margin-bottom: 1rem; }
        .board { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #3b82f6; display: grid; grid-template-columns: repeat(7, 1fr); grid-template-rows: repeat(6, 1fr); gap: 8px; padding: 8px; border-radius: 1rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1); }
        .cell { background-color: #f3f4f6; border-radius: 50%; display: flex; justify-content: center; align-items: center; }
        .cell .piece { width: 90%; height: 90%; border-radius: 50%; transform: scale(0); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .cell .piece.player1 { background-color: #ef4444; box-shadow: inset 0 0 10px rgba(0,0,0,0.4); transform: scale(1); }
        .cell .piece.player2 { background-color: #facc15; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); transform: scale(1); }
        #column-selectors { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: grid; grid-template-columns: repeat(7, 1fr); z-index: 10; }
        .column { cursor: pointer; border-radius: 0.5rem; transition: background-color 0.2s ease-in-out; }
        .column:hover { background-color: rgba(255, 255, 255, 0.2); }
        .column.disabled { cursor: not-allowed; }
        .column.disabled:hover { background-color: transparent; }
        .winning-cell .piece { animation: bounce 0.8s ease-in-out infinite; }
        @keyframes bounce { 0%, 100% { transform: scale(1.05); } 50% { transform: scale(0.85); } }
    </style>
</head>
<body>

    <!-- Transition Screen -->
    <div id="transition-screen" class="fixed inset-0 bg-black flex flex-col items-center justify-center z-50">
        <!-- Site Title -->
        <h1 id="transition-text" class="font-bold text-green-500 text-center px-4 break-words" style="font-family: 'Press Start 2P', cursive; font-size: clamp(1rem, 5vw, 2rem);">BrettIsGay.com</h1>
    </div>

    <!-- Page Container -->
    <div id="app-container">
        
        <!-- Brett's Feed Page -->
        <div id="feed-page" class="page">
            <header class="bg-white border-b border-gray-300 sticky top-0 z-10" style="background-color: #f5f3ef; background-image: url('https://www.transparenttextures.com/patterns/light-paper-fibers.png');">
                <div class="max-w-4xl mx-auto py-3 px-4 text-center">
                    <h1 class="text-4xl md:text-5xl text-gray-700" style="font-family: 'Gochi Hand', cursive;">BrettIsGay.com</h1>
                </div>
            </header>

            <!-- Info Section -->
            <div class="max-w-4xl mx-auto px-4 pt-6 text-center">
                <p class="text-xl md:text-2xl text-gray-800" style="font-family: 'Gochi Hand', cursive;">
                    Brett is super gay and we all know it.
                </p>
            </div>

            <main id="feed-container" class="max-w-4xl mx-auto p-4 md:p-8">
            </main>

            <div class="max-w-4xl mx-auto p-4 text-center pb-12">
                <p class="text-2xl text-gray-600" style="font-family: 'Gochi Hand', cursive;">
                    I NEED YOUR HELP! This Website is only the begining, please send your GAY photos of Brett to brettisgaydotcom@gmail.com Also MERCH COMING SOON! Thanks for scrolling! That's all the gay stuff for now.
                </p>
            </div>
        </div>

        <!-- Games Page -->
        <div id="games-page" class="page">
            <canvas id="matrix-canvas"></canvas>
            <button id="matrix-back-btn" class="absolute top-4 left-4 z-30 text-white bg-black bg-opacity-50 p-2 rounded-full hidden back-to-menu-btn">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
            </button>

            <!-- Game Selection Menu -->
            <div id="game-selection-menu" class="w-full h-full flex flex-col items-center justify-center space-y-8 p-8">
                 <h1 class="text-5xl font-bold text-white" style="font-family: 'Press Start 2P', cursive;">SELECT GAME</h1>
                 <button data-game="breakout" class="game-select-btn text-2xl bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">Breakout Deluxe</button>
                 <button data-game="connect-four" class="game-select-btn text-2xl bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">Connect Four</button>
                 <button data-game="matrix-mode" class="game-select-btn text-2xl bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">Matrix Mode</button>
            </div>

            <!-- Breakout Game Container -->
            <div id="breakout-game-container" class="game-container hidden w-full h-full">
                 <button class="absolute top-2 left-2 z-50 text-white bg-black bg-opacity-50 p-2 rounded-full back-to-menu-btn">
                     <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                 </button>
                 <div id="game-wrapper">
                     <div id="game-container">
                         <canvas id="breakoutCanvas"></canvas>
                         <div id="ui-overlay">
                             <div id="score">SCORE: 0</div>
                             <div id="level-display">LEVEL: 1</div>
                             <div id="lives">LIVES: 3</div>
                         </div>
                         <div id="modal">
                             <h2 id="modal-text">BREAKOUT</h2>
                             <p id="modal-subtitle">Deluxe Edition</p>
                             <button id="start-btn">START GAME</button>
                         </div>
                     </div>
                 </div>
            </div>

            <!-- Connect Four Game Container -->
            <div id="connect-four-container" class="game-container hidden w-full h-full">
                 <button class="absolute top-2 left-2 z-50 text-black bg-white bg-opacity-50 p-2 rounded-full back-to-menu-btn">
                     <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                 </button>
                 <div class="w-full max-w-lg text-center mb-4">
                     <h1 class="text-4xl md:text-5xl font-bold text-blue-600 mb-2">Connect Four vs. AI</h1>
                     <div id="status" class="text-lg md:text-xl h-8 font-semibold transition-colors duration-300 text-gray-800">Your Turn (Red)</div>
                 </div>
                 <div id="board-container">
                     <div class="board" id="board"></div>
                     <div id="column-selectors"></div>
                 </div>
                 <button id="newGame" class="mt-4 px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-all duration-200">New Game</button>
            </div>
        </div>
    </div>

    <!-- Modals (Game Specific) -->
    <div id="winnerModal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl p-8 text-center transform transition-all scale-95 opacity-0">
            <h2 id="winnerText" class="text-3xl font-bold mb-4"></h2>
            <button id="playAgain" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors">Play Again</button>
        </div>
    </div>

    <!-- Bottom Navigation Menu -->
    <nav class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-300 flex justify-around h-16 z-20">
        <button data-page="feed-page" class="nav-button flex-1 flex flex-col items-center justify-center text-sm text-blue-500">
            <svg class="w-6 h-6 mb-1" fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path></svg>
            Feed
        </button>
        <!-- Golf Button Removed -->
        <button data-page="games-page" class="nav-button flex-1 flex flex-col items-center justify-center text-sm text-gray-500">
            <svg class="w-6 h-6 mb-1" fill="currentColor" viewBox="0 0 20 20"><path d="M11 17a1 1 0 001.447.894l4-2A1 1 0 0017 15V5a1 1 0 00-1.447-.894l-4 2A1 1 0 0011 7v10zM4 17a1 1 0 001.447.894l4-2A1 1 0 0010 15V5a1 1 0 00-1.447-.894l-4 2A1 1 0 004 7v10z"></path></svg>
            Games
        </button>
    </nav>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- ELEMENTS ---
            const transitionScreen = document.getElementById('transition-screen');
            const navButtons = document.querySelectorAll('.nav-button');
            const pages = document.querySelectorAll('.page');
            let activeGameLoop = null;

            // --- INITIAL LOAD TRANSITION ---
            // Increased to 3000ms (3 seconds) so people can read "This is Brett" and see the photo
            setTimeout(() => {
                transitionScreen.style.opacity = '0';
                transitionScreen.addEventListener('transitionend', () => {
                    transitionScreen.style.display = 'none';
                }, { once: true });
            }, 3000); 

            // --- MASTER PAGE NAVIGATION ---
            function showPage(pageId) {
                const currentPage = document.querySelector('.page.active');
                if (currentPage && currentPage.id === pageId) {
                    return; 
                }

                // Stop any running game loops
                if (activeGameLoop) {
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }

                // Hide all pages
                pages.forEach(page => page.classList.remove('active'));
                
                // Show the target page
                const targetPage = document.getElementById(pageId);
                if (targetPage) {
                    targetPage.classList.add('active');
                } else {
                    // Fallback if page ID doesn't exist (e.g., old local storage data)
                    document.getElementById('feed-page').classList.add('active');
                    pageId = 'feed-page';
                }

                // Update nav buttons
                navButtons.forEach(button => {
                    const isSelected = button.dataset.page === pageId;
                    button.classList.toggle('text-blue-500', isSelected);
                    button.classList.toggle('text-gray-500', !isSelected);
                });

                // Save the last page to local storage
                localStorage.setItem('lastActivePage', pageId);

                // Handle game page specific logic
                if (pageId === 'games-page') {
                    showGameSelection();
                }
            }

            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showPage(button.dataset.page);
                });
            });

            // --- FEED APP INITIALIZATION ---
            function initFeedApp() {
                const feedContainer = document.getElementById('feed-container');
                
                const photoData = [
                    { imageUrl: 'images/intro_brett.jpg', caption: 'This is Brett' },
                    { imageUrl: 'images/Brett kissin a gay dude.jpg', caption: 'Mega Gay!' },
                    { imageUrl: 'images/brett carson 1.jpg', caption: 'Brett, Gay. Carson, avoiding Gay stuff' },
                    { imageUrl: 'images/brett carson 2.jpg', caption: 'Super Gay!' },
                    { imageUrl: 'images/gay field.jpg', caption: 'Gay!' }
                ];

                function renderFeed() {
                    if (!feedContainer) return;
                    feedContainer.innerHTML = '';
                    photoData.forEach(post => {
                        const postElement = createPostElement(post);
                        feedContainer.appendChild(postElement);
                    });
                }

                function createPostElement(post) {
                    const article = document.createElement('article');
                    article.className = 'post-card';
                    
                    // Apply a random rotation for the scrapbook effect
                    const rotation = Math.random() * 8 - 4; // between -4 and 4 degrees
                    article.style.transform = `rotate(${rotation}deg)`;

                    const image = `<img src="${post.imageUrl}" alt="${post.caption}" onerror="this.onerror=null;this.src='https://placehold.co/600x400/ccc/ffffff?text=Image+Not+Found';">`;
                    const caption = `<p class="caption">${post.caption}</p>`;
                    
                    article.innerHTML = image + caption;
                    return article;
                }
                
                renderFeed();
            }

            // --- GOLF APP DELETED ---
            // The Golf App logic and UI has been removed as requested.

            // --- GAMES APP LOGIC ---
            const gameSelectionMenu = document.getElementById('game-selection-menu');
            const gameSelectBtns = document.querySelectorAll('.game-select-btn');
            const gameContainers = document.querySelectorAll('.game-container');
            const backToMenuBtns = document.querySelectorAll('.back-to-menu-btn');
            const matrixCanvas = document.getElementById('matrix-canvas');
            const matrixBackBtn = document.getElementById('matrix-back-btn');

            function showGameSelection() {
                if (activeGameLoop) {
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }
                gameSelectionMenu.style.display = 'flex';
                gameContainers.forEach(c => c.classList.add('hidden'));
                matrixCanvas.classList.remove('fullscreen');
                matrixCanvas.style.display = 'block';
                matrixBackBtn.classList.add('hidden');
                initMatrixRain(); // Start rain for menu background
            }

            function showGame(gameName) {
                if (activeGameLoop) {
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }
                gameSelectionMenu.style.display = 'none';
                matrixCanvas.style.display = 'none'; // Hide matrix background for games
                matrixBackBtn.classList.add('hidden');

                gameContainers.forEach(c => {
                    c.classList.toggle('hidden', c.id !== `${gameName}-container`);
                    c.classList.toggle('flex', c.id === `${gameName}-container`);
                });
                if (gameName === 'breakout-game') {
                    initBreakoutGame();
                } else if (gameName === 'connect-four') {
                    initConnectFourGame();
                }
            }
            
            function showMatrixMode() {
                if (activeGameLoop) { // Ensure previous loop is stopped
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }
                gameSelectionMenu.style.display = 'none';
                gameContainers.forEach(c => c.classList.add('hidden'));
                matrixCanvas.style.display = 'block';
                matrixCanvas.classList.add('fullscreen');
                matrixBackBtn.classList.remove('hidden');
                initMatrixRain(); // Start/restart rain
            }

            gameSelectBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const game = btn.dataset.game;
                    if (game === 'breakout') {
                        showGame('breakout-game');
                    } else if (game === 'connect-four') {
                        showGame('connect-four');
                    } else if (game === 'matrix-mode') {
                        showMatrixMode();
                    }
                });
            });
            
            backToMenuBtns.forEach(btn => {
                btn.addEventListener('click', showGameSelection);
            });
            matrixBackBtn.addEventListener('click', showGameSelection);

            // --- MATRIX RAIN INITIALIZATION ---
            function initMatrixRain() {
                const canvas = document.getElementById('matrix-canvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                // The phrase to be spelled out, with spaces.
                const phrase = "BRETT  IS  GAY  ";

                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                const fontSize = 16;
                const columns = Math.floor(canvas.width / fontSize);

                // Each element in rainDrops is now an object tracking its y position and its character index in the phrase.
                const rainDrops = [];
                for(let i = 0; i < columns; i++) {
                    rainDrops[i] = {
                        y: Math.random() * canvas.height, // Start at a random height
                        charIndex: Math.floor(Math.random() * phrase.length) // Start at a random character
                    };
                }

                function drawMatrix() {
                    // Semi-transparent black background for the fading trail effect
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#0F0'; // Classic green color
                    ctx.font = fontSize + 'px monospace';

                    for(let i = 0; i < rainDrops.length; i++) {
                        // Get the correct character from the phrase based on the stream's current index
                        const text = phrase.charAt(rainDrops[i].charIndex);
                        
                        // Only draw the character if it's not a space
                        if (text !== ' ') {
                            ctx.fillText(text, i * fontSize, rainDrops[i].y * fontSize);
                        }
                        
                        // If the stream has gone off-screen, reset it to the top with a new random character index
                        if(rainDrops[i].y * fontSize > canvas.height && Math.random() > 0.975){
                            rainDrops[i].y = 0;
                            rainDrops[i].charIndex = Math.floor(Math.random() * phrase.length);
                        }

                        // Move the stream down for the next frame
                        rainDrops[i].y++;
                        
                        // Move to the next character in the phrase, looping back to the start if necessary
                        rainDrops[i].charIndex = (rainDrops[i].charIndex + 1) % phrase.length;
                    }
                }

                function animateMatrix() {
                    drawMatrix();
                    activeGameLoop = requestAnimationFrame(animateMatrix);
                }
                
                if (activeGameLoop) cancelAnimationFrame(activeGameLoop);
                animateMatrix();
            }

            // --- BREAKOUT GAME INITIALIZATION ---
            function initBreakoutGame() {
                const canvas = document.getElementById('breakoutCanvas');
                const ctx = canvas.getContext('2d');
                const scoreEl = document.getElementById('score');
                const livesEl = document.getElementById('lives');
                const levelEl = document.getElementById('level-display');
                const modal = document.getElementById('modal');
                const modalText = document.getElementById('modal-text');
                const modalSubtitle = document.getElementById('modal-subtitle');
                const startBtn = document.getElementById('start-btn');

                let score = 0, lives = 3, level = 1;
                let gameState = 'start-screen';
                let levelTransitionEndTime = 0;
                const baseWidth = 480, baseHeight = 640;
                let scale = 1;
                let extraLifeDroppedThisLevel = false;
                let lifeLostThisLevel = false;
                let hasUsedExtraLifeChance = false;

                let powerUpState = { isFireballShooter: false, fireballShooterEndTime: 0, nextFireballTime: 0, isBallShooter: false, ballShooterEndTime: 0, nextBallTime: 0, isFastBall: false, fastBallEndTime: 0 };
                let balls = [], bricks = [], powerUps = [], fireballs = [];
                const paddle = { x: 0, y: 0, width: 100, height: 10, color: '#FF00FF', baseWidth: 100 };
                const enemyAIPaddle = { x: 0, y: 0, width: 100, height: 10, color: '#FF4500', active: false };
                const cornerBumperSize = 30;
                const brickInfo = { rowCount: 7, columnCount: 7, width: 55, height: 20, padding: 10, offsetTop: 50 };
                const brickColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#8B00FF'];
                const multiHitColors = { 3: '#FFD700', 2: '#C0C0C0', 1: '#CD7F32' };

                let synth, metalSynth, brickHitSynth, brickBreakSynth, megatronSynth, audioInitialized = false;
                let lastSoundTime = 0;

                function playSoundSafe(synth, ...args) {
                    if (!audioInitialized || !synth) return;
                    try {
                        let time = Tone.now();
                        if (time <= lastSoundTime) {
                            time = lastSoundTime + 0.05; // Increased offset
                        }
                        synth.triggerAttackRelease(...args, time);
                        lastSoundTime = time;
                    } catch (e) {
                        // Fail silently if there's a rare scheduling conflict
                    }
                }

                function initAudio() {
                    if (audioInitialized) return;
                    try {
                        if (Tone.context.state !== 'running') { Tone.start(); }
                        synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination();
                        metalSynth = new Tone.MetalSynth({ frequency: 100, envelope: { attack: 0.01, decay: 0.2, release: 0.1 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
                        brickHitSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                        brickBreakSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, volume: -12, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination();
                        megatronSynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 14, detune: 0, oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.4 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.4 } }).toDestination();
                        audioInitialized = true;
                        lastSoundTime = 0;
                    } catch (e) { console.error("Could not initialize audio:", e); }
                }

                function resizeAndScale() {
                    const { width, height } = canvas.getBoundingClientRect();
                    canvas.width = width; canvas.height = height;
                    scale = Math.min(width / baseWidth, height / baseHeight);
                    paddle.width = paddle.baseWidth * scale;
                    paddle.height = 10 * scale;
                    enemyAIPaddle.width = 100 * scale;
                    enemyAIPaddle.height = 10 * scale;
                    brickInfo.width = 55 * scale;
                    brickInfo.height = 20 * scale;
                    brickInfo.padding = 10 * scale;
                    brickInfo.offsetTop = 60 * scale;
                    brickInfo.offsetLeft = (canvas.width - (brickInfo.columnCount * (brickInfo.width + brickInfo.padding) - brickInfo.padding)) / 2;
                    paddle.y = canvas.height - 30 * scale;
                    enemyAIPaddle.y = canvas.height / 3;
                }

                function createBricks(currentLevel) {
                    bricks = [];
                    const layouts = [
                        (c, r) => ({ health: 1, color: brickColors[r] }),
                        (c, r) => { if (r >= 3 && c >= r - 3 && c <= 9 - r) { const health = (r === 3 || c === r - 3 || c === 9 - r) ? 2 : 1; return { health, color: health === 2 ? multiHitColors[2] : brickColors[r] }; } return null; },
                        (c, r) => { if ((c + r) % 2 === 0) { const health = (c > 1 && c < 5 && r > 1 && r < 5) ? 3 : 1; return { health, color: health === 3 ? multiHitColors[3] : brickColors[r] }; } return null; },
                        (c, r) => { if (c === 0 || c === 6 || r === 0 || r === 6) return { health: 2, color: multiHitColors[2] }; if (c === 1 || c === 5 || r === 1 || r === 5) return { health: 1, color: brickColors[r] }; if (c > 1 && c < 5 && r > 1 && r < 5) return { health: 3, color: multiHitColors[3] }; return null; },
                        (c, r) => { if (c % 2 === 0) { const health = r < 2 ? 2 : 1; return { health, color: health === 2 ? multiHitColors[2] : brickColors[r] }; } return null; },
                        (c, r) => { if ((r === 1 || r === 2) && (c === 1 || c === 5)) return { health: 2, color: multiHitColors[2] }; if (r === 4 && c > 0 && c < 6) return { health: 1, color: brickColors[1] }; if (r === 5 && (c === 1 || c === 5)) return { health: 1, color: brickColors[1] }; return null; },
                        (c, r) => { if (c === 0 || c === 6 || r === 0) return { health: 3, color: multiHitColors[3] }; if (r > 2 && (c === 2 || c === 4)) return { health: 2, color: multiHitColors[2] }; if (r === 4 && c === 3) return { health: 1, color: brickColors[0] }; return null; },
                        (c, r) => { if ((c === 1 && r === 1) || (c === 5 && r === 1) || (c === 3 && r === 4) || (c === 1 && r === 6) || (c === 5 && r === 6)) return { health: 3, color: multiHitColors[3] }; return null; },
                        (c, r) => { const health = (c + r) % 2 === 0 ? 3 : 1; return { health, color: health === 3 ? multiHitColors[3] : brickColors[r] }; },
                        (c, r) => ({ health: 3, color: multiHitColors[3] })
                    ];
                    const layoutFunc = layouts[Math.min(currentLevel - 1, layouts.length - 1)];
                    for (let c = 0; c < brickInfo.columnCount; c++) {
                        bricks[c] = [];
                        for (let r = 0; r < brickInfo.rowCount; r++) {
                            const brickProps = layoutFunc(c, r);
                            if (brickProps) {
                                const brickX = c * (brickInfo.width + brickInfo.padding) + brickInfo.offsetLeft;
                                const brickY = r * (brickInfo.height + brickInfo.padding) + brickInfo.offsetTop;
                                bricks[c][r] = { x: brickX, y: brickY, status: 1, initialHealth: brickProps.health, ...brickProps };
                            } else {
                                bricks[c][r] = { status: 0 };
                            }
                        }
                    }
                }

                function createBall(x, y, dx, dy, type = 'normal') {
                    let newBall = { x, y, radius: 8 * scale, dx: dx * scale, dy: dy * scale, type, isFast: false };
                    if (powerUpState.isFastBall) {
                        newBall.isFast = true;
                        newBall.dx *= 1.5;
                        newBall.dy *= 1.5;
                    }
                    return newBall;
                }

                function createFireball() {
                    fireballs.push({ x: paddle.x + paddle.width / 2, y: paddle.y, radius: 6 * scale, dy: -8 * scale, color: '#FF4500' });
                    playSoundSafe(synth, "A5", "16n");
                }

                function shootExtraBall() {
                    balls.push(createBall(paddle.x + paddle.width / 2, paddle.y, (Math.random() - 0.5) * 4, -4));
                    playSoundSafe(synth, "G5", "16n");
                }

                function createPowerUp(x, y) {
                    let type;
                    const symbols = { 'enlarge': 'E', 'super-ball': 'S', 'multi-ball': 'M', 'extra-life': '+', 'fast-ball': 'F', 'fireball-shooter': 'C', 'ball-shooter': 'B' };
                    if (!extraLifeDroppedThisLevel && Math.random() < 0.1) {
                        type = 'extra-life';
                        extraLifeDroppedThisLevel = true;
                    } else {
                        const rand = Math.random();
                        if (rand < 0.30) { type = 'multi-ball'; }
                        else {
                            const remainingTypes = ['enlarge', 'super-ball', 'fast-ball', 'fireball-shooter', 'ball-shooter'];
                            type = remainingTypes[Math.floor(Math.random() * remainingTypes.length)];
                        }
                    }
                    if (type) {
                        powerUps.push({ x, y, type, symbol: symbols[type], size: 15 * scale, dy: 2 * scale });
                    }
                }

                function draw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBricks();
                    drawPaddle();
                    if (enemyAIPaddle.active) drawEnemyAIPaddle();
                    drawPowerUps();
                    drawBalls();
                    drawFireballs();
                    drawCornerBumpers();
                }

                function drawCornerBumpers() { const size = cornerBumperSize * scale; ctx.fillStyle = '#444'; ctx.beginPath(); ctx.moveTo(0, canvas.height - size); ctx.lineTo(size, canvas.height); ctx.lineTo(0, canvas.height); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(canvas.width, canvas.height - size); ctx.lineTo(canvas.width - size, canvas.height); ctx.lineTo(canvas.width, canvas.height); ctx.closePath(); ctx.fill(); }
                function drawBalls() { balls.forEach(ball => { ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fillStyle = ball.type === 'super' ? '#FFA500' : '#00FFFF'; ctx.fill(); ctx.closePath(); }); }
                function drawFireballs() { fireballs.forEach(fb => { ctx.beginPath(); ctx.arc(fb.x, fb.y, fb.radius, 0, Math.PI * 2); ctx.fillStyle = fb.color; ctx.fill(); ctx.closePath(); }); }
                function drawPaddle() { ctx.beginPath(); ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height); ctx.fillStyle = paddle.color; ctx.fill(); ctx.closePath(); }
                function drawEnemyAIPaddle() { ctx.beginPath(); ctx.rect(enemyAIPaddle.x, enemyAIPaddle.y, enemyAIPaddle.width, enemyAIPaddle.height); ctx.fillStyle = enemyAIPaddle.color; ctx.fill(); ctx.closePath(); }
                function drawBricks() { bricks.flat().forEach(b => { if (b.status === 1) { ctx.beginPath(); ctx.rect(b.x, b.y, brickInfo.width, brickInfo.height); ctx.fillStyle = b.health > 1 ? multiHitColors[b.health] : b.color; ctx.fill(); ctx.closePath(); } }); }
                function drawPowerUps() { powerUps.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fillStyle = '#FF00FF'; ctx.fill(); ctx.fillStyle = '#FFFFFF'; ctx.font = `bold ${p.size}px 'Press Start 2P'`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(p.symbol, p.x, p.y); ctx.closePath(); }); }

                function update() {
                    let powerUpsToActivate = [];
                    moveBalls();
                    updateFireballs();
                    powerUpsToActivate = updatePowerUps();
                    powerUpsToActivate.forEach(type => activatePowerUp(type));
                    updateActivePowerUps();
                    if (enemyAIPaddle.active) updateEnemyAIPaddle();
                }

                function updateEnemyAIPaddle() { let targetBall = balls.reduce((lowest, ball) => ball.y > lowest.y ? ball : lowest, {y: -Infinity}); if(targetBall.y !== -Infinity) { enemyAIPaddle.x += (targetBall.x - (enemyAIPaddle.x + enemyAIPaddle.width / 2)) * 0.12; } if (enemyAIPaddle.x < 0) enemyAIPaddle.x = 0; if (enemyAIPaddle.x + enemyAIPaddle.width > canvas.width) enemyAIPaddle.x = canvas.width - enemyAIPaddle.width; }
                function moveBalls() {
                    const collisions = [];
                    balls.forEach(ball => {
                        ball.x += ball.dx;
                        ball.y += ball.dy;
                        if (ball.x > canvas.width - ball.radius || ball.x < ball.radius) { ball.dx = -ball.dx; }
                        if (ball.y < ball.radius) { ball.dy = -ball.dy; }
                        const size = cornerBumperSize * scale;
                        if (ball.y > canvas.height - size) {
                            if (ball.x < size && ball.dy > 0) { ball.dx = Math.abs(ball.dy); ball.dy = -Math.abs(ball.dx); playSoundSafe(synth, "E4", "8n"); }
                            if (ball.x > canvas.width - size && ball.dy > 0) { ball.dx = -Math.abs(ball.dy); ball.dy = -Math.abs(ball.dx); playSoundSafe(synth, "E4", "8n"); }
                        }
                        if (enemyAIPaddle.active && ball.y < enemyAIPaddle.y + enemyAIPaddle.height + ball.radius && ball.dy < 0) { if (ball.x > enemyAIPaddle.x && ball.x < enemyAIPaddle.x + enemyAIPaddle.width) { ball.dy = -ball.dy; playSoundSafe(synth, "G3", "8n"); } }
                        if (ball.y > paddle.y - ball.radius && ball.y < paddle.y + paddle.height && ball.x > paddle.x && ball.x < paddle.x + paddle.width) { let collidePoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2); let currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy); let angle; if (Math.abs(collidePoint) < 0.1) { angle = (collidePoint >= 0 ? 1 : -1) * (Math.PI / 8); } else { angle = collidePoint * (Math.PI / 3); } ball.dx = currentSpeed * Math.sin(angle); ball.dy = -currentSpeed * Math.cos(angle); ball.y += ball.dy; playSoundSafe(synth, "C4", "8n"); }
                        const hitBrick = brickCollisionDetection(ball);
                        if (hitBrick) { collisions.push({ ball, brick: hitBrick }); }
                    });
                    collisions.forEach(({ ball, brick }) => resolveBrickCollision(ball, brick));
                    const initialBallCount = balls.length;
                    balls = balls.filter(ball => ball.y < canvas.height);
                    if (balls.length < initialBallCount && balls.length > 0) playSoundSafe(synth, "C3", "8n");
                    if (balls.length === 0 && gameState === 'playing') {
                        lives--;
                        lifeLostThisLevel = true;
                        playSoundSafe(metalSynth, "C2", "4n");
                        if (lives <= 0) gameOver(); else resetBallAndPaddle();
                    }
                }

                function updateFireballs() { fireballs.forEach((fb, index) => { fb.y += fb.dy; if (fb.y < 0) { fireballs.splice(index, 1); return; } for (const b of bricks.flat()) { if (b.status === 1 && fb.x > b.x && fb.x < b.x + brickInfo.width && fb.y > b.y && fb.y < b.y + brickInfo.height) { fireballs.splice(index, 1); handleBrickHit(b); return; } } }); }
                function handleBrickHit(b) { if (b.status !== 1) return; b.health--; score += 10; if (b.health <= 0) { playSoundSafe(brickBreakSynth, "8n"); b.status = 0; score += 20; const isSpecialLevel = level >= 5 && level <= 8; const enemyChance = isSpecialLevel ? 0.10 : 0.03; let powerUpChance; if (b.initialHealth > 1) { powerUpChance = 0.80; } else { powerUpChance = isSpecialLevel ? 0.40 : 0.25; } if (Math.random() < enemyChance && !enemyAIPaddle.active) { activateEnemyAI(); } else if (Math.random() < powerUpChance) { createPowerUp(b.x + brickInfo.width / 2, b.y + brickInfo.height / 2); } } else { playSoundSafe(brickHitSynth, "C2", "8n"); } checkWin(); }
                function brickCollisionDetection(ball) { for (const b of bricks.flat()) { if (b.status !== 1) continue; const closestX = Math.max(b.x, Math.min(ball.x, b.x + brickInfo.width)); const closestY = Math.max(b.y, Math.min(ball.y, b.y + brickInfo.height)); const distanceX = ball.x - closestX; const distanceY = ball.y - closestY; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); if (distanceSquared < (ball.radius * ball.radius)) { return b; } } return null; }
                function resolveBrickCollision(ball, b) { if (b.status !== 1) return; if (ball.type !== 'super') { const closestX = Math.max(b.x, Math.min(ball.x, b.x + brickInfo.width)); const closestY = Math.max(b.y, Math.min(ball.y, b.y + brickInfo.height)); const distanceX = ball.x - closestX; const distanceY = ball.y - closestY; const overlapX = ball.radius - Math.abs(distanceX); const overlapY = ball.radius - Math.abs(distanceY); if (overlapX > overlapY) { ball.dy = -ball.dy; ball.y += ball.dy > 0 ? overlapY : -overlapY; } else { ball.dx = -ball.dx; ball.x += ball.dx > 0 ? overlapX : -overlapX; } } handleBrickHit(b); }
                function updatePowerUps() { const collectedPowerUps = []; powerUps = powerUps.filter(p => { p.y += p.dy; if (p.y > paddle.y && p.x > paddle.x && p.x < paddle.x + paddle.width) { collectedPowerUps.push(p.type); return false; } return p.y < canvas.height; }); return collectedPowerUps; }
                function updateActivePowerUps() { const now = Date.now(); if (powerUpState.isFireballShooter) { if (now > powerUpState.fireballShooterEndTime) { powerUpState.isFireballShooter = false; } else if (now > powerUpState.nextFireballTime) { createFireball(); powerUpState.nextFireballTime = now + 1000; } } if (powerUpState.isBallShooter) { if (now > powerUpState.ballShooterEndTime) { powerUpState.isBallShooter = false; } else if (now > powerUpState.nextBallTime) { shootExtraBall(); powerUpState.nextBallTime = now + 2000; } } if (powerUpState.isFastBall && now > powerUpState.fastBallEndTime) { powerUpState.isFastBall = false; balls.forEach(ball => { if (ball.isFast) { ball.dx /= 1.5; ball.dy /= 1.5; ball.isFast = false; } }); } }
                function activatePowerUp(type) { playSoundSafe(synth, "C6", "8n"); if (type === 'enlarge') { paddle.baseWidth = 150; resizeAndScale(); setTimeout(() => { paddle.baseWidth = 100; resizeAndScale(); }, 10000); } else if (type === 'super-ball') { balls.forEach(b => b.type = 'super'); setTimeout(() => balls.forEach(b => b.type = 'normal'), 10000); } else if (type === 'multi-ball') { const originalBalls = [...balls]; originalBalls.forEach(b => { balls.push(createBall(b.x, b.y, b.dx + 1, b.dy)); balls.push(createBall(b.x, b.y, b.dx - 1, b.dy)); }); } else if (type === 'extra-life') { lives++; } else if (type === 'fast-ball') { if (!powerUpState.isFastBall) { balls.forEach(ball => { ball.dx *= 1.5; ball.dy *= 1.5; ball.isFast = true; }); } powerUpState.isFastBall = true; powerUpState.fastBallEndTime = Date.now() + 8000; } else if (type === 'fireball-shooter') { powerUpState.isFireballShooter = true; powerUpState.fireballShooterEndTime = Date.now() + 10000; powerUpState.nextFireballTime = Date.now(); } else if (type === 'ball-shooter') { powerUpState.isBallShooter = true; powerUpState.ballShooterEndTime = Date.now() + 10000; powerUpState.nextBallTime = Date.now(); } }
                function activateEnemyAI() { enemyAIPaddle.active = true; if(audioInitialized) { const now = Tone.now(); megatronSynth.triggerAttackRelease("G2", "4n", now); megatronSynth.triggerAttackRelease("C3", "4n", now + 0.3); megatronSynth.triggerAttackRelease("F2", "2n", now + 0.6); } setTimeout(() => { enemyAIPaddle.active = false; }, 10000); }

                function checkWin() { if (bricks.flat().every(b => b.status === 0)) { if (!lifeLostThisLevel) { lives++; } if (level === 10) { winGame(); return; } gameState = 'level-transition'; level++; powerUps = []; fireballs = []; powerUpState.isFireballShooter = false; powerUpState.isBallShooter = false; powerUpState.isFastBall = false; playSoundSafe(synth, "G5", "2n"); levelTransitionEndTime = Date.now() + 2500; } }
                function startNextLevel() { extraLifeDroppedThisLevel = false; lifeLostThisLevel = false; createBricks(level); resetBallAndPaddle(); }
                function resetBallAndPaddle() { balls = [createBall(canvas.width / 2, canvas.height - 50 * scale, 4 * (Math.random() > 0.5 ? 1 : -1), -4)]; paddle.x = (canvas.width - paddle.width) / 2; }
                function resetGame() { score = 0; lives = 3; level = 1; powerUps = []; fireballs = []; powerUpState = { isFireballShooter: false, fireballShooterEndTime: 0, nextFireballTime: 0, isBallShooter: false, ballShooterEndTime: 0, nextBallTime: 0, isFastBall: false, fastBallEndTime: 0 }; enemyAIPaddle.active = false; extraLifeDroppedThisLevel = false; hasUsedExtraLifeChance = false; lifeLostThisLevel = false; resizeAndScale(); createBricks(level); resetBallAndPaddle(); }
                function gameOver() { if (!hasUsedExtraLifeChance) { gameState = 'extra-life-prompt'; hasUsedExtraLifeChance = true; } else { gameState = 'game-over'; } }
                function winGame() { gameState = 'game-won'; }
                function startGame() { initAudio(); resetGame(); gameState = 'playing'; }

                function loop() {
                    if (gameState === 'playing') { update(); } 
                    else if (gameState === 'level-transition') { if (Date.now() > levelTransitionEndTime) { startNextLevel(); gameState = 'playing'; } }
                    draw();
                    updateUI();
                    activeGameLoop = requestAnimationFrame(loop);
                }

                function updateUI() { scoreEl.textContent = `SCORE: ${score}`; livesEl.textContent = `LIVES: ${lives}`; levelEl.textContent = `LEVEL: ${level}`; if (gameState === 'start-screen' || gameState === 'game-over') { modal.style.display = 'block'; startBtn.style.display = 'block'; modalText.textContent = gameState === 'start-screen' ? 'BREAKOUT' : 'GAME OVER'; modalSubtitle.textContent = gameState === 'start-screen' ? 'Deluxe Edition' : `Final Score: ${score}`; startBtn.textContent = gameState === 'start-screen' ? 'START GAME' : 'RESTART'; } else if (gameState === 'extra-life-prompt') { modal.style.display = 'block'; startBtn.style.display = 'block'; modalText.textContent = "You're out of lives..."; modalSubtitle.textContent = "But you can have one more."; startBtn.textContent = "Admit you are a bitch"; } else if (gameState === 'game-won') { modal.style.display = 'block'; startBtn.style.display = 'block'; modalText.textContent = "Congratu-Fucking-lations"; modalSubtitle.textContent = "You won!!!"; startBtn.textContent = "Play Again?"; } else if (gameState === 'level-transition') { modal.style.display = 'block'; startBtn.style.display = 'none'; modalText.textContent = `LEVEL ${level}`; modalSubtitle.textContent = "Get Ready!"; } else { modal.style.display = 'none'; } }
                function movePaddle(x) { paddle.x = x - paddle.width / 2; if (paddle.x < 0) { paddle.x = 0; } if (paddle.x + paddle.width > canvas.width) { paddle.x = canvas.width - paddle.width; } }
                function handleMove(e) { if (e.type.includes('touch')) { e.preventDefault(); } const rect = canvas.getBoundingClientRect(); const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX; if (clientX === undefined) return; movePaddle(clientX - rect.left); }

                canvas.addEventListener('mousemove', handleMove);
                canvas.addEventListener('touchmove', handleMove, { passive: false });
                canvas.addEventListener('touchstart', handleMove, { passive: false });
                startBtn.addEventListener('click', () => { if (gameState === 'start-screen' || gameState === 'game-over' || gameState === 'game-won') { startGame(); } else if (gameState === 'extra-life-prompt') { lives = 1; resetBallAndPaddle(); gameState = 'playing'; } });
                window.addEventListener('resize', () => { resizeAndScale(); draw(); updateUI(); });
                
                resizeAndScale();
                loop();
            }

            // --- CONNECT FOUR GAME INITIALIZATION ---
            function initConnectFourGame() {
                const boardElement = document.getElementById('board');
                const columnSelectorsElement = document.getElementById('column-selectors');
                const statusElement = document.getElementById('status');
                const newGameButton = document.getElementById('newGame');
                const winnerModal = document.getElementById('winnerModal');
                const winnerModalContent = winnerModal.querySelector('div');
                const winnerText = document.getElementById('winnerText');
                const playAgainButton = document.getElementById('playAgain');

                const ROWS = 6;
                const COLS = 7;
                const HUMAN_PLAYER = 1;
                const AI_PLAYER = 2;
                let board = [];
                let currentPlayer = HUMAN_PLAYER;
                let gameOver = false;

                function createBoard() {
                    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
                    gameOver = false;
                    currentPlayer = HUMAN_PLAYER;
                    boardElement.innerHTML = '';
                    columnSelectorsElement.innerHTML = '';
                    for (let row = 0; row < ROWS; row++) {
                        for (let col = 0; col < COLS; col++) {
                            const cell = document.createElement('div');
                            cell.classList.add('cell');
                            cell.dataset.row = row;
                            cell.dataset.col = col;
                            boardElement.appendChild(cell);
                        }
                    }
                    for (let col = 0; col < COLS; col++) {
                        const column = document.createElement('div');
                        column.classList.add('column');
                        column.dataset.col = col;
                        column.addEventListener('click', () => handleColumnClick(col));
                        columnSelectorsElement.appendChild(column);
                    }
                    updateStatus();
                    toggleColumnSelectors(true);
                }

                function handleColumnClick(col) {
                    if (gameOver || currentPlayer !== HUMAN_PLAYER) return;
                    const row = findAvailableRow(board, col);
                    if (row === -1) return;
                    dropPiece(row, col, HUMAN_PLAYER);
                    if (gameOver) return;
                    currentPlayer = AI_PLAYER;
                    updateStatus();
                    toggleColumnSelectors(false);
                    setTimeout(aiMove, 500);
                }

                function aiMove() {
                    statusElement.textContent = "Computer is thinking...";
                    const { col } = minimax(board, 7, -Infinity, Infinity, true);
                    if (col === null) {
                        gameOver = true;
                        showWinner("It's a Draw!");
                        return;
                    }
                    const row = findAvailableRow(board, col);
                    dropPiece(row, col, AI_PLAYER);
                    if (gameOver) return;
                    currentPlayer = HUMAN_PLAYER;
                    updateStatus();
                    toggleColumnSelectors(true);
                }

                function findAvailableRow(b, col) { for (let row = ROWS - 1; row >= 0; row--) { if (b[row][col] === 0) return row; } return -1; }
                function dropPiece(row, col, player) {
                    board[row][col] = player;
                    const piece = document.createElement('div');
                    piece.classList.add('piece', `player${player}`);
                    const targetCell = document.querySelector(`#connect-four-container .cell[data-row='${row}'][data-col='${col}']`);
                    targetCell.appendChild(piece);
                    if (checkForWin(board, player)) {
                        gameOver = true;
                        if (player === HUMAN_PLAYER) { showWinner("You won! Screenshot for a free suprise from Brett."); } 
                        else { showWinner("The Computer Wins! You're Gay!"); }
                        highlightWinningCells(board, player);
                    } else if (isBoardFull(board)) {
                        gameOver = true;
                        showWinner("It's a Draw! Brett's still Gay!");
                    }
                }

                function updateStatus() { if (gameOver) return; if (currentPlayer === HUMAN_PLAYER) { statusElement.textContent = "Your Turn (Red)"; statusElement.style.color = '#ef4444'; } else { statusElement.textContent = "Computer's Turn (Yellow)"; statusElement.style.color = '#facc15'; } }
                function toggleColumnSelectors(enabled) { columnSelectorsElement.style.pointerEvents = enabled ? 'auto' : 'none'; }
                function showWinner(message) { statusElement.textContent = message; winnerText.textContent = message; winnerModal.classList.remove('hidden'); winnerModal.classList.add('flex'); setTimeout(() => { winnerModalContent.style.transform = 'scale(1)'; winnerModalContent.style.opacity = '1'; }, 50); }
                function isBoardFull(b) { return b[0].every(cell => cell !== 0); }
                function checkForWin(b, player) { for (let r = 0; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r][c+1] === player && b[r][c+2] === player && b[r][c+3] === player) return true; } } for (let c = 0; c < COLS; c++) { for (let r = 0; r <= ROWS - 4; r++) { if (b[r][c] === player && b[r+1][c] === player && b[r+2][c] === player && b[r+3][c] === player) return true; } } for (let r = 0; r <= ROWS - 4; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r+1][c+1] === player && b[r+2][c+2] === player && b[r+3][c+3] === player) return true; } } for (let r = 3; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r-1][c+1] === player && b[r-2][c+2] === player && b[r-3][c+3] === player) return true; } } return false; }
                function highlightWinningCells(b, player) {
                    let winningLine = [];
                    const findLine = () => {
                        for (let r = 0; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r][c+1] === player && b[r][c+2] === player && b[r][c+3] === player) return [{r,c},{r,c:c+1},{r,c:c+2},{r,c:c+3}]; } }
                        for (let c = 0; c < COLS; c++) { for (let r = 0; r <= ROWS - 4; r++) { if (b[r][c] === player && b[r+1][c] === player && b[r+2][c] === player && b[r+3][c] === player) return [{r,c},{r:r+1,c},{r:r+2,c},{r:r+3,c}]; } }
                        for (let r = 0; r <= ROWS - 4; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r+1][c+1] === player && b[r+2][c+2] === player && b[r+3][c+3] === player) return [{r,c},{r:r+1,c:c+1},{r:r+2,c:c+2},{r:r+3,c:c+3}]; } }
                        for (let r = 3; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r-1][c+1] === player && b[r-2][c+2] === player && b[r-3][c+3] === player) return [{r,c},{r:r-1,c:c+1},{r:r-2,c:c+2},{r:r-3,c:c+3}]; } }
                        return [];
                    };
                    winningLine = findLine();
                    winningLine.forEach(pos => {
                        const cellElement = document.querySelector(`#connect-four-container .cell[data-row='${pos.r}'][data-col='${pos.c}']`);
                        if (cellElement) cellElement.classList.add('winning-cell');
                    });
                }
                function scorePosition(b, player) {
                    let score = 0;
                    const centerArray = b.map(row => row[Math.floor(COLS / 2)]);
                    score += centerArray.filter(p => p === player).length * 6;
                    const scoreLine = (line, p) => {
                        let s = 0;
                        const opponentPlayer = p === AI_PLAYER ? HUMAN_PLAYER : AI_PLAYER;
                        const playerCount = line.filter(val => val === p).length;
                        const emptyCount = line.filter(val => val === 0).length;
                        const opponentCount = line.filter(val => val === opponentPlayer).length;
                        if (playerCount === 4) s += 1000000;
                        else if (playerCount === 3 && emptyCount === 1) s += 5000;
                        else if (playerCount === 2 && emptyCount === 2) s += 50;
                        if (opponentCount === 3 && emptyCount === 1) s -= 10000;
                        return s;
                    };
                    for (let r = 0; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { score += scoreLine(b[r].slice(c, c + 4), player); } }
                    for (let c = 0; c < COLS; c++) { for (let r = 0; r <= ROWS - 4; r++) { score += scoreLine([b[r][c], b[r+1][c], b[r+2][c], b[r+3][c]], player); } }
                    for (let r = 0; r <= ROWS - 4; r++) { for (let c = 0; c <= COLS - 4; c++) { score += scoreLine([b[r][c], b[r+1][c+1], b[r+2][c+2], b[r+3][c+3]], player); } }
                    for (let r = 3; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { score += scoreLine([b[r][c], b[r-1][c+1], b[r-2][c+2], b[r-3][c+3]], player); } }
                    return score;
                }
                function getValidLocations(b) { return [...Array(COLS).keys()].filter(c => b[0][c] === 0); }
                function minimax(b, depth, alpha, beta, maximizingPlayer) {
                    const isTerminal = checkForWin(b, HUMAN_PLAYER) || checkForWin(b, AI_PLAYER) || isBoardFull(b);
                    if (depth === 0 || isTerminal) {
                        if (isTerminal) {
                            if (checkForWin(b, AI_PLAYER)) return { col: null, score: 10000000 };
                            if (checkForWin(b, HUMAN_PLAYER)) return { col: null, score: -10000000 };
                            return { col: null, score: 0 };
                        }
                        return { col: null, score: scorePosition(b, AI_PLAYER) };
                    }
                    const validLocations = getValidLocations(b);
                    const columnOrder = [3, 4, 2, 5, 1, 6, 0];
                    const prioritizedLocations = columnOrder.filter(col => validLocations.includes(col));
                    if (maximizingPlayer) {
                        let value = -Infinity;
                        let column = prioritizedLocations[0];
                        for (const col of prioritizedLocations) {
                            let b_copy = b.map(r => [...r]);
                            const row = findAvailableRow(b_copy, col);
                            b_copy[row][col] = AI_PLAYER;
                            let new_score = minimax(b_copy, depth - 1, alpha, beta, false).score;
                            if (new_score > value) {
                                value = new_score;
                                column = col;
                            }
                            alpha = Math.max(alpha, value);
                            if (alpha >= beta) break;
                        }
                        return { col: column, score: value };
                    } else { // Minimizing player
                        let value = Infinity;
                        let column = prioritizedLocations[0];
                        for (const col of prioritizedLocations) {
                            let b_copy = b.map(r => [...r]);
                            const row = findAvailableRow(b_copy, col);
                            b_copy[row][col] = HUMAN_PLAYER;
                            let new_score = minimax(b_copy, depth - 1, alpha, beta, true).score;
                            if (new_score < value) {
                                value = new_score;
                                column = col;
                            }
                            beta = Math.min(beta, value);
                            if (alpha >= beta) break;
                        }
                        return { col: column, score: value };
                    }
                }
                function resetGame() {
                    winnerModal.classList.remove('flex');
                    winnerModal.classList.add('hidden');
                    createBoard();
                }
                newGameButton.addEventListener('click', createBoard);
                playAgainButton.addEventListener('click', resetGame);
                createBoard();
            }

            // --- INITIALIZE ALL APPS ---
            initFeedApp();
            
            // Start on the last visited page or feed page by default
            let lastPage = localStorage.getItem('lastActivePage') || 'feed-page';
            showPage(lastPage);
        });
    </script>
</body>
</html>
