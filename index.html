<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Brett's World</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Gochi+Hand&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* A neutral background for the whole app */
            overflow: hidden; /* Prevent scrolling on the body */
            touch-action: none;
        }
        #app-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 4rem; /* Height of the nav bar */
            overflow: hidden;
        }
        .page {
            display: none; /* Hide pages by default */
            width: 100%;
            height: 100%;
            overflow-y: auto;
        }
        .page.active {
            display: block; /* Show active page */
        }

        /* Feed Page Styles */
        #feed-page {
             background-color: #f5f3ef;
             background-image: url('https://www.transparenttextures.com/patterns/light-paper-fibers.png');
        }
        .post-card {
            background-color: white;
            padding: 1rem;
            padding-bottom: 3.5rem; /* Space for caption */
            border-radius: 0.25rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            position: relative;
            break-inside: avoid;
            margin-bottom: 1.5rem;
        }
        .post-card img {
            width: 100%;
            height: auto;
            border: 1px solid #eee;
        }
        .post-card .caption {
            font-family: 'Gochi Hand', cursive;
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            text-align: center;
            font-size: 1.25rem;
            color: #333;
        }
        
        #feed-container {
            column-count: 2;
            column-gap: 1.5rem;
        }
        @media (max-width: 640px) {
            #feed-container {
                column-count: 1;
            }
        }


        /* Golf Caddie Page Styles */
        #golf-page {
            background-color: #111827; /* bg-gray-900 */
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        .animate-fadeIn { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .scorecard-table { border-collapse: separate; border-spacing: 0.25rem 0; }
        .modal { display: none; }
        .modal.active { display: flex; }
        .modal { z-index: 50; }

        /* Game Page Styles */
        #games-page {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            position: relative;
        }
        .game-container { display: none; }
        .game-container.active { display: flex; }
        #game-selection-menu {
            position: relative;
            z-index: 10;
        }
        #matrix-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #matrix-canvas.fullscreen {
            z-index: 20;
        }

        /* Breakout Game Styles */
        #breakout-game-container {
            font-family: 'Press Start 2P', cursive;
            color: #FFFFFF;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        #game-wrapper { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        #game-container { border: 4px solid #00FFFF; border-radius: 10px; box-shadow: 0 0 20px #FF00FF, inset 0 0 20px #FF00FF; position: relative; width: 100%; height: 100%; max-width: 480px; max-height: 800px; }
        #breakoutCanvas { background-color: #000; display: block; width: 100%; height: 100%; cursor: pointer; }
        #ui-overlay { position: absolute; top: 15px; left: 20px; right: 20px; display: flex; justify-content: space-between; color: #fff; font-size: clamp(12px, 3vw, 1rem); pointer-events: none; text-shadow: 2px 2px 4px #FF00FF; }
        #modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 10px; border: 4px solid #00FFFF; text-align: center; z-index: 100; width: 80%; display: none; }
        #modal h2 { font-size: clamp(1.5em, 5vw, 2em); margin-bottom: 10px; color: #FFFF00; }
        #modal p { font-size: clamp(0.8em, 3vw, 1em); margin-bottom: 20px; color: #00FFFF; }
        #modal button { background-color: #FF00FF; color: white; padding: 15px 25px; border: 2px solid white; border-radius: 5px; font-family: 'Press Start 2P', cursive; cursor: pointer; font-size: clamp(0.8em, 4vw, 1em); box-shadow: 0 0 10px #fff; }

        /* Connect Four Game Styles */
        #connect-four-container {
            font-family: 'Poppins', sans-serif;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 1rem;
            background-color: #f3f4f6; /* gray-100 */
        }
        #board-container { position: relative; width: 100%; max-width: 560px; aspect-ratio: 7 / 6; margin-bottom: 1rem; }
        .board { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #3b82f6; display: grid; grid-template-columns: repeat(7, 1fr); grid-template-rows: repeat(6, 1fr); gap: 8px; padding: 8px; border-radius: 1rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1); }
        .cell { background-color: #f3f4f6; border-radius: 50%; display: flex; justify-content: center; align-items: center; }
        .cell .piece { width: 90%; height: 90%; border-radius: 50%; transform: scale(0); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .cell .piece.player1 { background-color: #ef4444; box-shadow: inset 0 0 10px rgba(0,0,0,0.4); transform: scale(1); }
        .cell .piece.player2 { background-color: #facc15; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); transform: scale(1); }
        #column-selectors { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: grid; grid-template-columns: repeat(7, 1fr); z-index: 10; }
        .column { cursor: pointer; border-radius: 0.5rem; transition: background-color 0.2s ease-in-out; }
        .column:hover { background-color: rgba(255, 255, 255, 0.2); }
        .column.disabled { cursor: not-allowed; }
        .column.disabled:hover { background-color: transparent; }
        .winning-cell .piece { animation: bounce 0.8s ease-in-out infinite; }
        @keyframes bounce { 0%, 100% { transform: scale(1.05); } 50% { transform: scale(0.85); } }
    </style>
</head>
<body>

    <!-- Page Container -->
    <div id="app-container">
        
        <!-- Brett's Feed Page -->
        <div id="feed-page" class="page">
            <header class="bg-white border-b border-gray-300 sticky top-0 z-10" style="background-color: #f5f3ef; background-image: url('https://www.transparenttextures.com/patterns/light-paper-fibers.png');">
                <div class="max-w-4xl mx-auto py-3 px-4 text-center">
                    <h1 class="text-5xl text-gray-700" style="font-family: 'Gochi Hand', cursive;">Brett's Scrapbook</h1>
                </div>
            </header>
            <main id="feed-container" class="max-w-4xl mx-auto p-4 md:p-8">
                <!-- Scrapbook photos will be injected here -->
            </main>
        </div>

        <!-- Golf Caddie Page -->
        <div id="golf-page" class="page">
             <div id="golf-app-container" class="w-full max-w-md mx-auto p-4 pt-8 pb-12">
                 <!-- All Golf App content will be rendered here -->
             </div>
        </div>

        <!-- Games Page -->
        <div id="games-page" class="page">
            <canvas id="matrix-canvas"></canvas>
            <button id="matrix-back-btn" class="absolute top-4 left-4 z-30 text-white bg-black bg-opacity-50 p-2 rounded-full hidden back-to-menu-btn">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
            </button>

            <!-- Game Selection Menu -->
            <div id="game-selection-menu" class="w-full h-full flex flex-col items-center justify-center space-y-8 p-8">
                 <h1 class="text-5xl font-bold text-white" style="font-family: 'Press Start 2P', cursive;">SELECT GAME</h1>
                 <button data-game="breakout" class="game-select-btn text-2xl bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">Breakout Deluxe</button>
                 <button data-game="connect-four" class="game-select-btn text-2xl bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">Connect Four</button>
                 <button data-game="matrix-mode" class="game-select-btn text-2xl bg-green-600 hover:bg-green-700 text-white font-bold py-4 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105">Matrix Mode</button>
            </div>

            <!-- Breakout Game Container -->
            <div id="breakout-game-container" class="game-container hidden w-full h-full">
                 <button class="absolute top-2 left-2 z-50 text-white bg-black bg-opacity-50 p-2 rounded-full back-to-menu-btn">
                     <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                 </button>
                 <div id="game-wrapper">
                     <div id="game-container">
                         <canvas id="breakoutCanvas"></canvas>
                         <div id="ui-overlay">
                             <div id="score">SCORE: 0</div>
                             <div id="level-display">LEVEL: 1</div>
                             <div id="lives">LIVES: 3</div>
                         </div>
                         <div id="modal">
                             <h2 id="modal-text">BREAKOUT</h2>
                             <p id="modal-subtitle">Deluxe Edition</p>
                             <button id="start-btn">START GAME</button>
                         </div>
                     </div>
                 </div>
            </div>

            <!-- Connect Four Game Container -->
            <div id="connect-four-container" class="game-container hidden w-full h-full">
                 <button class="absolute top-2 left-2 z-50 text-black bg-white bg-opacity-50 p-2 rounded-full back-to-menu-btn">
                     <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                 </button>
                 <div class="w-full max-w-lg text-center mb-4">
                     <h1 class="text-4xl md:text-5xl font-bold text-blue-600 mb-2">Connect Four vs. AI</h1>
                     <div id="status" class="text-lg md:text-xl h-8 font-semibold transition-colors duration-300 text-gray-800">Your Turn (Red)</div>
                 </div>
                 <div id="board-container">
                     <div class="board" id="board"></div>
                     <div id="column-selectors"></div>
                 </div>
                 <button id="newGame" class="mt-4 px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-all duration-200">New Game</button>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="save-modal" class="modal fixed inset-0 bg-black/60 backdrop-blur-sm items-center justify-center p-4">
        <div class="bg-gray-800 border border-white/10 rounded-2xl shadow-2xl p-6 w-full max-w-sm animate-fadeIn">
            <h2 class="text-2xl font-bold text-center mb-4">Save Round</h2>
            <p class="text-center text-gray-400 mb-4">Enter a name for this round.</p>
            <input type="text" id="course-name-input" class="w-full text-center bg-gray-700 border border-gray-600 rounded-lg p-3 mb-4" placeholder="Course Name">
            <div class="grid grid-cols-2 gap-3">
                <button id="cancel-save" class="w-full bg-gray-600 text-white font-bold py-3 rounded-lg">Cancel</button>
                <button id="confirm-save" class="w-full bg-blue-500 text-white font-bold py-3 rounded-lg">Save</button>
            </div>
        </div>
    </div>
    <div id="add-club-modal" class="modal fixed inset-0 bg-black/60 backdrop-blur-sm items-center justify-center p-4">
        <div class="bg-gray-800 border border-white/10 rounded-2xl shadow-2xl p-6 w-full max-w-sm animate-fadeIn">
            <h2 class="text-2xl font-bold text-center mb-4">Add New Club</h2>
            <input type="text" id="new-club-name" class="w-full text-center bg-gray-700 border border-gray-600 rounded-lg p-3 mb-2" placeholder="Club Name">
            <div class="grid grid-cols-2 gap-3 mb-4">
                <input type="number" id="new-club-min" class="w-full text-center bg-gray-700 border border-gray-600 rounded-lg p-3" placeholder="Min Yards">
                <input type="number" id="new-club-max" class="w-full text-center bg-gray-700 border border-gray-600 rounded-lg p-3" placeholder="Max Yards">
            </div>
            <div class="grid grid-cols-2 gap-3">
                <button id="cancel-add-club" class="w-full bg-gray-600 text-white font-bold py-3 rounded-lg">Cancel</button>
                <button id="confirm-add-club" class="w-full bg-green-500 text-gray-900 font-bold py-3 rounded-lg">Add Club</button>
            </div>
        </div>
    </div>
    <div id="delete-round-modal" class="modal fixed inset-0 bg-black/60 backdrop-blur-sm items-center justify-center p-4">
        <div class="bg-gray-800 border border-white/10 rounded-2xl shadow-2xl p-6 w-full max-w-sm animate-fadeIn">
            <h2 class="text-2xl font-bold text-center mb-4">Delete Round?</h2>
            <p id="delete-round-text" class="text-center text-gray-400 mb-4">This action cannot be undone.</p>
            <div class="grid grid-cols-2 gap-3">
                <button id="cancel-delete-round" class="w-full bg-gray-600 text-white font-bold py-3 rounded-lg">Cancel</button>
                <button id="confirm-delete-round" class="w-full bg-red-500 text-white font-bold py-3 rounded-lg">Delete</button>
            </div>
        </div>
    </div>
    <div id="winnerModal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl p-8 text-center transform transition-all scale-95 opacity-0">
            <h2 id="winnerText" class="text-3xl font-bold mb-4"></h2>
            <button id="playAgain" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors">Play Again</button>
        </div>
    </div>

    <!-- Bottom Navigation Menu -->
    <nav class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-300 flex justify-around h-16 z-20">
        <button data-page="feed-page" class="nav-button flex-1 flex flex-col items-center justify-center text-sm text-blue-500">
            <svg class="w-6 h-6 mb-1" fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path></svg>
            Feed
        </button>
        <button data-page="golf-page" class="nav-button flex-1 flex flex-col items-center justify-center text-sm text-gray-500">
            <svg class="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
            Golf
        </button>
        <button data-page="games-page" class="nav-button flex-1 flex flex-col items-center justify-center text-sm text-gray-500">
            <svg class="w-6 h-6 mb-1" fill="currentColor" viewBox="0 0 20 20"><path d="M11 17a1 1 0 001.447.894l4-2A1 1 0 0017 15V5a1 1 0 00-1.447-.894l-4 2A1 1 0 0011 7v10zM4 17a1 1 0 001.447.894l4-2A1 1 0 0010 15V5a1 1 0 00-1.447-.894l-4 2A1 1 0 004 7v10z"></path></svg>
            Games
        </button>
    </nav>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- MASTER PAGE NAVIGATION ---
            const navButtons = document.querySelectorAll('.nav-button');
            const pages = document.querySelectorAll('.page');
            let activeGameLoop = null;

            function showPage(pageId) {
                if (activeGameLoop) {
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }

                pages.forEach(page => {
                    page.classList.toggle('active', page.id === pageId);
                });
                navButtons.forEach(button => {
                    const isSelected = button.dataset.page === pageId;
                    button.classList.toggle('text-blue-500', isSelected);
                    button.classList.toggle('text-gray-500', !isSelected);
                });
                
                if (pageId === 'games-page') {
                    showGameSelection();
                }
            }

            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    showPage(button.dataset.page);
                });
            });

            // --- FEED APP INITIALIZATION ---
            function initFeedApp() {
                const feedContainer = document.getElementById('feed-container');
                
                // All photo data is now stored here. No database needed.
                const photoData = [
                    { imageUrl: 'https://placehold.co/600x600/3498db/ffffff?text=Brett+at+the+Park', caption: 'A beautiful day at the park!' },
                    { imageUrl: 'https://placehold.co/600x400/e74c3c/ffffff?text=Nap+Time', caption: 'Someone is all tuckered out.' },
                    { imageUrl: 'https://placehold.co/400x600/2ecc71/ffffff?text=Beach+Day', caption: 'First time seeing the ocean!' },
                    { imageUrl: 'https://placehold.co/600x600/9b59b6/ffffff?text=Birthday+Fun', caption: 'Happy Birthday, Brett!' },
                    { imageUrl: 'https://placehold.co/600x500/f1c40f/ffffff?text=Goofy+Face', caption: 'This one always makes me laugh.' }
                ];

                function renderFeed() {
                    if (!feedContainer) return;
                    feedContainer.innerHTML = '';
                    photoData.forEach(post => {
                        const postElement = createPostElement(post);
                        feedContainer.appendChild(postElement);
                    });
                }

                function createPostElement(post) {
                    const article = document.createElement('article');
                    article.className = 'post-card';
                    
                    // Apply a random rotation for the scrapbook effect
                    const rotation = Math.random() * 8 - 4; // between -4 and 4 degrees
                    article.style.transform = `rotate(${rotation}deg)`;

                    const image = `<img src="${post.imageUrl}" alt="${post.caption}" onerror="this.onerror=null;this.src='https://placehold.co/600x400/ccc/ffffff?text=Image+Not+Found';">`;
                    const caption = `<p class="caption">${post.caption}</p>`;
                    
                    article.innerHTML = image + caption;
                    return article;
                }
                
                renderFeed();
            }

            // --- GOLF CADDIE APP INITIALIZATION ---
            function initGolfApp() {
                const golfAppContainer = document.getElementById('golf-app-container');
                if (!golfAppContainer) return;

                let state = { clubs: [], scorecard: {}, history: [], confidence: 0, roundToDeleteIndex: null };
                const defaultClubs = [ { name: 'Driver', min: 200, max: 220, order: 1 }, { name: '4H', min: 185, max: 200, order: 2 }, { name: '6 Iron', min: 145, max: 160, order: 3 }, { name: '7 Iron', min: 140, max: 155, order: 4 }, { name: '8 Iron', min: 135, max: 150, order: 5 }, { name: '9 Iron', min: 130, max: 145, order: 6 }, { name: 'PW', min: 110, max: 135, order: 7 }, { name: 'A/GW', min: 100, max: 120, order: 8 } ];
                const createDefaultScorecard = () => ({ scores: Array(18).fill(0), pars: Array(18).fill(4), putts: Array(18).fill(0), roundType: 18 });
                
                const vibrate = () => { if ('vibrate' in navigator) navigator.vibrate(10); };
                
                const loadData = () => { try { state.clubs = JSON.parse(localStorage.getItem('golfCaddieClubs')) || defaultClubs; state.scorecard = JSON.parse(localStorage.getItem('golfCaddieScorecard')) || createDefaultScorecard(); if (!state.scorecard.putts || state.scorecard.putts.length !== 18) { state.scorecard.putts = Array(18).fill(0); } state.history = JSON.parse(localStorage.getItem('golfCaddieHistory')) || []; } catch (e) { console.error("Error loading data:", e); state.clubs = defaultClubs; state.scorecard = createDefaultScorecard(); state.history = []; } };
                const saveData = (key, data) => { try { localStorage.setItem(key, JSON.stringify(data)); } catch (e) { console.error(`Error saving ${key}:`, e); } };
                const saveClubs = () => { state.clubs.sort((a, b) => b.max - a.max); state.clubs.forEach((club, index) => club.order = index + 1); saveData('golfCaddieClubs', state.clubs); };
                const saveScorecard = () => saveData('golfCaddieScorecard', state.scorecard);
                const saveHistory = () => saveData('golfCaddieHistory', state.history);

                const showModal = (modalId) => document.getElementById(modalId).classList.add('active');
                const hideModal = (modalId) => document.getElementById(modalId).classList.remove('active');

                function displayGolfView(html) {
                    golfAppContainer.innerHTML = html;
                    const distanceInput = golfAppContainer.querySelector('#distance-input');
                    if (distanceInput) {
                        distanceInput.addEventListener('input', findBestClub);
                    }
                    const confidenceSlider = golfAppContainer.querySelector('#confidence-slider');
                    if(confidenceSlider) {
                        const normalButton = confidenceSlider.querySelector('button[data-value="0"]');
                        if(normalButton) {
                            normalButton.classList.add('bg-green-500', 'text-gray-900');
                            normalButton.classList.remove('text-gray-300', 'hover:bg-gray-600');
                        }
                        confidenceSlider.addEventListener('click', (e) => {
                            const button = e.target.closest('button');
                            if(button) {
                                vibrate();
                                state.confidence = parseInt(button.dataset.value, 10);
                                confidenceSlider.querySelectorAll('button').forEach(btn => {
                                    btn.classList.remove('bg-green-500', 'text-gray-900');
                                    btn.classList.add('text-gray-300', 'hover:bg-gray-600');
                                });
                                button.classList.add('bg-green-500', 'text-gray-900');
                                button.classList.remove('text-gray-300', 'hover:bg-gray-600');
                                findBestClub();
                            }
                        });
                    }
                }

                const getScoreColor = (score, par) => {
                    if (score === 0) return 'text-white';
                    const diff = score - par;
                    if (diff <= 0) return 'text-green-400';
                    if (diff === 1) return 'text-white';
                    if (diff === 2) return 'text-yellow-400';
                    return 'text-red-400';
                };

                const findBestClub = () => {
                    const distanceInput = document.getElementById('distance-input');
                    const resultContainer = document.getElementById('result-container');
                    if (!distanceInput || !resultContainer) return;
                    const numDistance = parseInt(distanceInput.value, 10);
                    if (isNaN(numDistance) || numDistance <= 0) {
                        resultContainer.innerHTML = '<p class="text-gray-500">Enter a yardage to get a suggestion.</p>';
                        return;
                    }
                    const calculateScore = (club) => {
                        if (state.confidence === 1) return Math.abs(numDistance - club.max);
                        if (state.confidence === -1) return Math.abs(numDistance - club.min);
                        return Math.abs(numDistance - (club.min + club.max) / 2);
                    };
                    const rankedClubs = state.clubs.map(club => ({ club, score: calculateScore(club) })).sort((a, b) => a.score - b.score);
                    let suggestions = rankedClubs.slice(0, 2).map(item => item.club);
                    if (rankedClubs.length > 2 && rankedClubs[2].score <= 15) {
                        suggestions.push(rankedClubs[2].club);
                    }
                    renderResult(`For ${numDistance} yds, your best options are:`, suggestions);
                };

                const renderResult = (prompt, suggestions) => {
                    const resultContainer = document.getElementById('result-container');
                    if (!resultContainer) return;
                    const rankColors = ['text-green-400', 'text-yellow-400', 'text-red-400'];
                    let html = `<p class="text-xl text-gray-400 mb-3">${prompt}</p><div class="space-y-4 text-center">`;
                    suggestions.forEach((club, index) => {
                        const color = rankColors[index] || 'text-white';
                        const range = club.name === 'Driver' ? `${club.min}+ yds` : `${club.min}-${club.max} yds`;
                        html += `<div class="text-5xl font-bold ${color}">${club.name}<span class="block text-3xl font-normal text-white/90 mt-1">(${range})</span></div>`;
                        if (index < suggestions.length - 1) html += '<p class="text-lg text-gray-500 my-2">or</p>';
                    });
                    resultContainer.innerHTML = html + '</div>';
                };

                const renderCaddie = () => {
                    const html = `
                    <div class="bg-gray-800/50 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl p-6 animate-fadeIn">
                        <div class="flex justify-between items-center mb-6">
                            <h1 class="text-3xl font-bold text-green-400 flex items-center gap-3">
                                <svg class="w-8 h-8" viewBox="0 0 256 256" fill="currentColor"><path d="M216 32h-80a8 8 0 0 0-5.66 2.34L64 99.59V40a8 8 0 0 0-16 0v168a8 8 0 0 0 16 0v-59.59l66.34 65.25A8 8 0 0 0 136 216h80a8 8 0 0 0 8-8V40a8 8 0 0 0-8-8ZM138.34 128l-56-55.15L144.59 48H208v128h-63.41l62.07-60.85Z"></path></svg>
                                Caddie Pro
                            </h1>
                            <div class="flex items-center gap-2">
                                <button class="golf-nav-btn bg-gray-700/50 text-gray-400 hover:text-white transition p-2 rounded-full shadow-lg hover:bg-gray-700" data-page="history">
                                    <svg class="w-6 h-6 pointer-events-none" viewBox="0 0 256 256" fill="currentColor"><path d="M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm0,192a88,88,0,1,1,88-88A88.1,88.1,0,0,1,128,216Zm64-88a8,8,0,0,1-8,8H128a8,8,0,0,1-8-8V72a8,8,0,0,1,16,0v48h48A8,8,0,0,1,192,128Z"/></svg>
                                </button>
                                <button class="golf-nav-btn bg-gray-700/50 text-gray-400 hover:text-white transition p-2 rounded-full shadow-lg hover:bg-gray-700" data-page="scorecard">
                                    <svg class="w-6 h-6 pointer-events-none" viewBox="0 0 256 256" fill="currentColor"><path d="M216 40H40a16 16 0 0 0-16 16v144a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a16 16 0 0 0-16-16Zm0 160H40V56h176v144ZM100 88v80a8 8 0 0 1-16 0V88a8 8 0 0 1 16 0Zm48 0v80a8 8 0 0 1-16 0V88a8 8 0 0 1 16 0Zm48 0v80a8 8 0 0 1-16 0V88a8 8 0 0 1 16 0Z"></path></svg>
                                </button>
                                <button class="golf-nav-btn bg-gray-700/50 text-gray-400 hover:text-white transition p-2 rounded-full shadow-lg hover:bg-gray-700" data-page="settings">
                                <svg class="w-6 h-6 pointer-events-none" viewBox="0 0 256 256" fill="currentColor"><path d="M234.2,141.13,223.86,128l10.34-13.13a15.86,15.86,0,0,0-3.13-22.13l-13.12-10.34,13.12-10.34a15.86,15.86,0,0,0-3.13-22.13l-13.12-10.34L223.86,28,201.73,24.87l-10.34-13.12a15.86,15.86,0,0,0-22.13-3.13L156,21.73,142.87,11.39a15.86,15.86,0,0,0-22.13,3.13L107.62,24.87,94.5,11.39a15.86,15.86,0,0,0-22.13,3.13L59.25,24.87,48.91,11.39A15.86,15.86,0,0,0,26.78,14.52L16.44,24.87,3.32,38.25a15.86,15.86,0,0,0,3.13,22.13L16.79,70.72,3.67,81.06a15.86,15.86,0,0,0,3.13,22.13L16.44,113.53,3.32,126.87a15.86,15.86,0,0,0,3.13,22.13L21.73,159.34,11.39,172.47a15.86,15.86,0,0,0,3.13,22.13L24.87,204.94,11.39,218.06a15.86,15.86,0,0,0,3.13,22.13L24.87,250.53,38.25,253.66a15.86,15.86,0,0,0,22.13-3.13L70.72,237.09,81.06,250.21a15.86,15.86,0,0,0,22.13-3.13L113.53,236.75l10.34,13.12a15.86,15.86,0,0,0,22.13,3.13L159.34,242.91l13.12,10.34a15.86,15.86,0,0,0,22.13-3.13l10.34-13.12,13.12,10.34a15.86,15.86,0,0,0,22.13-3.13L242.91,232.53l10.34-13.12a15.86,15.86,0,0,0-3.13-22.13l-10.34-13.12,13.12-10.34a15.86,15.86,0,0,0,3.13-22.13ZM128,176a48,48,0,1,1,48-48A48.05,48.05,0,0,1,128,176Z"/></svg>
                                </button>
                            </div>
                        </div>
                        <div class="space-y-6">
                            <input type="number" id="distance-input" placeholder="Enter distance in yds" class="w-full text-center bg-gray-700 border border-gray-600 text-white text-lg rounded-lg p-4 focus:ring-2 focus:ring-green-500 focus:outline-none" />
                            <div>
                                <label class="block text-sm font-medium text-gray-400 mb-2 text-center">Shot Confidence</label>
                                <div id="confidence-slider" class="flex justify-between items-center bg-gray-700 rounded-lg p-1">
                                    <button data-value="-1" class="w-1/3 py-2 text-sm font-semibold rounded-md transition text-gray-300 hover:bg-gray-600">Smooth</button>
                                    <button data-value="0" class="w-1/3 py-2 text-sm font-semibold rounded-md transition text-gray-300 hover:bg-gray-600">Normal</button>
                                    <button data-value="1" class="w-1/3 py-2 text-sm font-semibold rounded-md transition text-gray-300 hover:bg-gray-600">Aggressive</button>
                                </div>
                            </div>
                        </div>
                        <div id="result-container" class="mt-8 min-h-[10rem] flex flex-col items-center justify-center">
                            <p class="text-gray-500">Enter a yardage to get a suggestion.</p>
                        </div>
                    </div>`;
                    displayGolfView(html);
                };
                
                const renderSettings = () => { let html = `<div class="bg-gray-800/50 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl p-6 animate-fadeIn"><div class="flex justify-between items-center mb-6"><h1 class="text-3xl font-bold text-green-400 flex items-center gap-3"><svg class="w-8 h-8" viewBox="0 0 256 256" fill="currentColor"><path d="M234.2,141.13,223.86,128l10.34-13.13a15.86,15.86,0,0,0-3.13-22.13l-13.12-10.34,13.12-10.34a15.86,15.86,0,0,0-3.13-22.13l-13.12-10.34L223.86,28,201.73,24.87l-10.34-13.12a15.86,15.86,0,0,0-22.13-3.13L156,21.73,142.87,11.39a15.86,15.86,0,0,0-22.13,3.13L107.62,24.87,94.5,11.39a15.86,15.86,0,0,0-22.13,3.13L59.25,24.87,48.91,11.39A15.86,15.86,0,0,0,26.78,14.52L16.44,24.87,3.32,38.25a15.86,15.86,0,0,0,3.13,22.13L16.79,70.72,3.67,81.06a15.86,15.86,0,0,0,3.13,22.13L16.44,113.53,3.32,126.87a15.86,15.86,0,0,0,3.13,22.13L21.73,159.34,11.39,172.47a15.86,15.86,0,0,0,3.13,22.13L24.87,204.94,11.39,218.06a15.86,15.86,0,0,0,3.13,22.13L24.87,250.53,38.25,253.66a15.86,15.86,0,0,0,22.13-3.13L70.72,237.09,81.06,250.21a15.86,15.86,0,0,0,22.13-3.13L113.53,236.75l10.34,13.12a15.86,15.86,0,0,0,22.13,3.13L159.34,242.91l13.12,10.34a15.86,15.86,0,0,0,22.13-3.13l10.34-13.12,13.12,10.34a15.86,15.86,0,0,0,22.13-3.13L242.91,232.53l10.34-13.12a15.86,15.86,0,0,0-3.13-22.13l-10.34-13.12,13.12-10.34a15.86,15.86,0,0,0,3.13-22.13ZM128,176a48,48,0,1,1,48-48A48.05,48.05,0,0,1,128,176Z"/></svg> My Clubs</h1><button class="golf-nav-btn text-gray-400 p-2 rounded-full hover:bg-gray-700" data-page="caddie"><svg class="w-8 h-8" viewBox="0 0 256 256" fill="currentColor"><path d="M204.83,115.17l-40-40a8,8,0,0,0-11.32,11.32L176.69,104H48a8,8,0,0,0,0,16h128.69l-23.18,23.17a8,8,0,0,0,11.32,11.32l40-40A8,8,0,0,0,204.83,115.17Z" transform="rotate(180 128 128)"></path></svg></button></div><div class="settings-clubs-container space-y-4 max-h-[60vh] overflow-y-auto pr-2">`; state.clubs.forEach((club, index) => { html += `<div class="p-4 bg-gray-700/50 rounded-lg"><div class="flex justify-between items-center mb-2"><p class="font-bold text-lg text-white">${club.name}</p><button class="delete-club text-red-500 hover:text-red-400" data-index="${index}"><svg class="w-6 h-6 pointer-events-none" viewBox="0 0 256 256" fill="currentColor"><path d="M216,48H176V40a24,24,0,0,0-24-24H104A24,24,0,0,0,80,40v8H40a8,8,0,0,0,0,16h8V208a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V64h8a8,8,0,0,0,0-16ZM96,40a8,8,0,0,1,8-8h48a8,8,0,0,1,8,8v8H96Zm96,168H64V64H192Zm-80-104v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm48,0v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Z"></path></svg></button></div><div class="flex items-center gap-4"><input type="number" data-index="${index}" data-field="min" value="${club.min}" class="club-input w-full text-center bg-gray-800 border border-gray-600 rounded-lg p-2" /><span class="text-gray-400">-</span><input type="number" data-index="${index}" data-field="max" value="${club.max}" class="club-input w-full text-center bg-gray-800 border border-gray-600 rounded-lg p-2" /></div></div>`; }); html += `</div><button class="add-new-club mt-4 w-full border-2 border-dashed border-gray-600 hover:border-green-500 hover:text-green-500 text-gray-400 font-bold py-3 rounded-lg transition">Add New Club</button><button class="save-clubs mt-2 w-full bg-green-500 text-gray-900 font-bold py-3 rounded-lg">Save & Close</button></div>`; displayGolfView(html); };
                const renderScorecard = () => { let html = `<div class="bg-gray-800/50 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl p-4 animate-fadeIn"><div class="flex justify-between items-center mb-4"><h1 class="text-3xl font-bold text-green-400">Scorecard</h1><button class="golf-nav-btn text-gray-400 p-2 rounded-full hover:bg-gray-700" data-page="caddie"><svg class="w-8 h-8" viewBox="0 0 256 256" fill="currentColor"><path d="M204.83,115.17l-40-40a8,8,0,0,0-11.32,11.32L176.69,104H48a8,8,0,0,0,0,16h128.69l-23.18,23.17a8,8,0,0,0,11.32,11.32l40-40A8,8,0,0,0,204.83,115.17Z" transform="rotate(180 128 128)"></path></svg></button></div><div class="round-type-selector flex justify-center items-center bg-gray-700 rounded-lg p-1 mb-4"><button data-type="9" class="w-1/2 py-2 text-sm font-semibold rounded-md transition">9 Holes</button><button data-type="18" class="w-1/2 py-2 text-sm font-semibold rounded-md transition">18 Holes</button></div><div id="scorecard-tables" class="space-y-4"></div><div id="scorecard-summary" class="mt-6 border-t border-gray-700 pt-4 flex justify-around items-center"></div><button class="finish-round mt-6 w-full bg-blue-500 text-white font-bold py-3 rounded-lg">Finish & Save Round</button></div>`; displayGolfView(html); updateScorecardView(); };
                const updateScorecardView = () => { const tablesContainer = document.getElementById('scorecard-tables'); const roundTypeSelector = document.querySelector('.round-type-selector'); if (!tablesContainer || !roundTypeSelector) return; roundTypeSelector.querySelectorAll('button').forEach(btn => { const isSelected = parseInt(btn.dataset.type) === state.scorecard.roundType; btn.classList.toggle('bg-green-500', isSelected); btn.classList.toggle('text-gray-900', isSelected); }); let tablesHTML = renderScorecardTable('Out', Array.from({length: 9}, (_, i) => i + 1), state.scorecard.scores.slice(0, 9), state.scorecard.pars.slice(0, 9), state.scorecard.putts.slice(0, 9), 0, true); if (state.scorecard.roundType === 18) { tablesHTML += renderScorecardTable('In', Array.from({length: 9}, (_, i) => i + 10), state.scorecard.scores.slice(9, 18), state.scorecard.pars.slice(9, 18), state.scorecard.putts.slice(9, 18), 9, true); } tablesContainer.innerHTML = tablesHTML; updateScorecardTotals(); };
                const renderScorecardTable = (title, holes, scores, pars, putts, startIndex, editable = false) => { let tableHTML = `<div class="w-full overflow-x-auto"><table class="w-full min-w-max text-center text-sm scorecard-table"><thead><tr class="text-gray-400"><th class="p-2 font-semibold">${title}</th>${holes.map(h => `<th class="p-2 font-semibold">${h}</th>`).join('')}<th class="p-2 font-semibold">Total</th></tr></thead><tbody class="bg-gray-700/50 rounded-lg"><tr><td class="p-2 text-gray-300">Par</td>${pars.map((p, i) => `<td class="p-2">${editable ? `<div class="flex items-center justify-center gap-2"><button data-type="par" data-index="${startIndex+i}" data-delta="-1" class="score-btn bg-gray-600 w-8 h-8 rounded-full font-bold text-lg flex items-center justify-center">-</button><span class="par-value font-bold text-xl w-6">${p}</span><button data-type="par" data-index="${startIndex+i}" data-delta="1" class="score-btn bg-gray-600 w-8 h-8 rounded-full font-bold text-lg flex items-center justify-center">+</button></div>` : `<span class="font-bold text-xl w-6">${p}</span>`}</td>`).join('')}<td class="par-total font-bold text-xl p-2">${pars.reduce((a,b)=>a+b,0)}</td></tr><tr><td class="p-2 text-gray-300">Score</td>${scores.map((s, i) => `<td class="p-2">${editable ? `<div class="flex items-center justify-center gap-2"><button data-type="score" data-index="${startIndex+i}" data-delta="-1" class="score-btn bg-red-500/80 w-8 h-8 rounded-full font-bold text-lg flex items-center justify-center">-</button><span class="score-value font-bold text-xl w-6 ${getScoreColor(s, pars[i])}">${s || '-'}</span><button data-type="score" data-index="${startIndex+i}" data-delta="1" class="score-btn bg-green-500/80 w-8 h-8 rounded-full font-bold text-lg flex items-center justify-center">+</button></div>` : `<span class="font-bold text-xl w-6 ${getScoreColor(s, pars[i])}">${s || '-'}</span>`}</td>`).join('')}<td class="score-total font-bold text-xl p-2">${scores.reduce((a,b)=>a+b,0)}</td></tr><tr><td class="p-2 text-gray-300">Putts</td>${putts.map((p, i) => `<td class="p-2">${editable ? `<div class="flex items-center justify-center gap-2"><button data-type="putt" data-index="${startIndex+i}" data-delta="-1" class="score-btn bg-gray-600 w-8 h-8 rounded-full font-bold text-lg flex items-center justify-center">-</button><span class="putt-value font-bold text-xl w-6">${p || '-'}</span><button data-type="putt" data-index="${startIndex+i}" data-delta="1" class="score-btn bg-gray-600 w-8 h-8 rounded-full font-bold text-lg flex items-center justify-center">+</button></div>` : `<span class="font-bold text-xl w-6">${p || '-'}</span>`}</td>`).join('')}<td class="putt-total font-bold text-xl p-2">${putts.reduce((a,b)=>a+b,0)}</td></tr></tbody></table></div>`; return tableHTML; };
                const updateScorecardTotals = () => { const summaryContainer = document.getElementById('scorecard-summary'); if (!summaryContainer) return; const numHoles = state.scorecard.roundType; const scores = state.scorecard.scores.slice(0, numHoles); const pars = state.scorecard.pars.slice(0, numHoles); const putts = state.scorecard.putts.slice(0, numHoles); const totalScore = scores.reduce((a, b) => a + b, 0); const totalPar = pars.reduce((a, b) => a + b, 0); const totalPutts = putts.reduce((a, b) => a + b, 0); const toPar = totalScore - totalPar; const toParStr = toPar > 0 ? `+${toPar}` : toPar === 0 ? 'E' : toPar; const toParColor = toPar <= 0 ? 'text-green-400' : 'text-yellow-400'; summaryContainer.innerHTML = `<div class="text-center"><p class="text-gray-400">Putts</p><p class="text-4xl font-bold">${totalPutts}</p></div><div class="text-center"><p class="text-gray-400">Total</p><p class="text-4xl font-bold">${totalScore}</p></div><div class="text-center"><p class="text-gray-400">To Par</p><p class="text-4xl font-bold ${toParColor}">${toParStr}</p></div>`; };
                const renderHistory = () => { let html = `<div class="bg-gray-800/50 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl p-6 animate-fadeIn"><div class="flex justify-between items-center mb-6"><h1 class="text-3xl font-bold text-green-400">Round History</h1><button class="golf-nav-btn text-gray-400 p-2 rounded-full hover:bg-gray-700" data-page="caddie"><svg class="w-8 h-8" viewBox="0 0 256 256" fill="currentColor"><path d="M204.83,115.17l-40-40a8,8,0,0,0-11.32,11.32L176.69,104H48a8,8,0,0,0,0,16h128.69l-23.18,23.17a8,8,0,0,0,11.32,11.32l40-40A8,8,0,0,0,204.83,115.17Z" transform="rotate(180 128 128)"></path></svg></button></div><div class="space-y-3 max-h-[70vh] overflow-y-auto pr-2">`; if (state.history.length === 0) { html += `<div class="text-center text-gray-400 p-8"><p class="text-lg">No saved rounds yet.</p><p class="text-sm">Finish a round on the Scorecard page to see it here.</p></div>`; } else { state.history.forEach((round, index) => { const date = new Date(round.date).toLocaleDateString(); const toPar = round.toPar > 0 ? `+${round.toPar}` : round.toPar === 0 ? 'E' : round.toPar; html += `<div class="bg-gray-700/50 p-4 rounded-lg flex justify-between items-center hover:bg-gray-700 transition"><div class="history-item flex-grow cursor-pointer" data-index="${index}"><p class="font-bold text-lg">${round.courseName}</p><p class="text-sm text-gray-400">${date} <span class="ml-2 bg-gray-600 px-2 py-0.5 rounded-full text-xs">${round.scorecard.roundType} Holes</span></p></div><div class="flex items-center gap-4"><div class="text-right history-item cursor-pointer" data-index="${index}"><p class="font-bold text-2xl">${round.totalScore}</p><p class="text-sm text-gray-400">(${toPar})</p></div><button class="delete-round text-red-500 hover:text-red-400 p-2 rounded-full hover:bg-gray-600" data-index="${index}"><svg class="w-6 h-6 pointer-events-none" viewBox="0 0 256 256" fill="currentColor"><path d="M216,48H176V40a24,24,0,0,0-24-24H104A24,24,0,0,0,80,40v8H40a8,8,0,0,0,0,16h8V208a16,16,0,0,0,16,16H192a16,16,0,0,0,16-16V64h8a8,8,0,0,0,0-16ZM96,40a8,8,0,0,1,8-8h48a8,8,0,0,1,8,8v8H96Zm96,168H64V64H192Zm-80-104v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Zm48,0v64a8,8,0,0,1-16,0V104a8,8,0,0,1,16,0Z"></path></svg></button></div></div>`; }); } html += `</div></div>`; displayGolfView(html); };
                const renderRoundDetail = (round) => { const toParStr = round.toPar > 0 ? `+${round.toPar}` : round.toPar === 0 ? 'E' : round.toPar; const toParColor = round.toPar <= 0 ? 'text-green-400' : 'text-yellow-400'; let tablesHTML = renderScorecardTable('Out', Array.from({length: 9}, (_, i) => i + 1), round.scorecard.scores.slice(0, 9), round.scorecard.pars.slice(0, 9), round.scorecard.putts.slice(0, 9), 0, false); if (round.scorecard.roundType === 18) { tablesHTML += renderScorecardTable('In', Array.from({length: 9}, (_, i) => i + 10), round.scorecard.scores.slice(9, 18), round.scorecard.pars.slice(9, 18), round.scorecard.putts.slice(9, 18), 9, false); } let html = `<div class="bg-gray-800/50 backdrop-blur-xl border border-white/10 rounded-2xl shadow-2xl p-4 animate-fadeIn"><div class="flex justify-between items-center mb-4"><h1 class="text-2xl font-bold text-green-400">${round.courseName}</h1><button class="golf-nav-btn text-gray-400 p-2 rounded-full hover:bg-gray-700" data-page="history"><svg class="w-8 h-8" viewBox="0 0 256 256" fill="currentColor"><path d="M204.83,115.17l-40-40a8,8,0,0,0-11.32,11.32L176.69,104H48a8,8,0,0,0,0,16h128.69l-23.18,23.17a8,8,0,0,0,11.32,11.32l40-40A8,8,0,0,0,204.83,115.17Z" transform="rotate(180 128 128)"></path></svg></button></div><p class="text-center text-gray-400 mb-4">${new Date(round.date).toLocaleDateString()}</p><div class="space-y-4">${tablesHTML}</div><div class="mt-6 border-t border-gray-700 pt-4 flex justify-around items-center"><div class="text-center"><p class="text-gray-400">Putts</p><p class="text-4xl font-bold">${round.totalPutts}</p></div><div class="text-center"><p class="text-gray-400">Total</p><p class="text-4xl font-bold">${round.totalScore}</p></div><div class="text-center"><p class="text-gray-400">To Par</p><p class="text-4xl font-bold ${toParColor}">${toParStr}</p></div></div></div>`; displayGolfView(html); };
                
                golfAppContainer.addEventListener('click', (e) => {
                    const historyItem = e.target.closest('.history-item');
                    if (historyItem) {
                        vibrate();
                        renderRoundDetail(state.history[historyItem.dataset.index]);
                        return;
                    }

                    const button = e.target.closest('button');
                    if (button) {
                        vibrate();
                        if (button.matches('.golf-nav-btn')) { const page = button.dataset.page; if (page === 'caddie') renderCaddie(); if (page === 'settings') renderSettings(); if (page === 'scorecard') renderScorecard(); if (page === 'history') renderHistory(); return; }
                        if (button.matches('.score-btn')) { const { type, index, delta } = button.dataset; const i = parseInt(index, 10); const fieldMap = { par: 'pars', score: 'scores', putt: 'putts' }; const valueMap = { par: 'par-value', score: 'score-value', putt: 'putt-value' }; const totalMap = { par: 'par-total', score: 'score-total', putt: 'putt-total' }; const targetArray = state.scorecard[fieldMap[type]]; const newValue = Math.max(0, (targetArray[i] || 0) + parseInt(delta)); targetArray[i] = newValue; saveScorecard(); const valueSpan = button.parentElement.querySelector(`.${valueMap[type]}`); if (valueSpan) { valueSpan.textContent = newValue || '-'; if (type === 'score') { valueSpan.className = `score-value font-bold text-xl w-6 ${getScoreColor(newValue, state.scorecard.pars[i])}`; } } const table = button.closest('table'); if (table) { const isOutTable = i < 9; const startIndex = isOutTable ? 0 : 9; const endIndex = isOutTable ? 9 : 18; const rowTotal = state.scorecard[fieldMap[type]].slice(startIndex, endIndex).reduce((a, b) => a + b, 0); const totalTd = table.querySelector(`.${totalMap[type]}`); if (totalTd) { totalTd.textContent = rowTotal; } } updateScorecardTotals(); return; }
                        if (button.matches('.save-clubs')) { const container = golfAppContainer.querySelector('.settings-clubs-container'); container.querySelectorAll('.club-input').forEach(input => { const index = parseInt(input.dataset.index, 10); const field = input.dataset.field; const value = parseInt(input.value, 10); if(state.clubs[index] && !isNaN(value)) { state.clubs[index][field] = value; } }); saveClubs(); button.textContent = 'Saved!'; setTimeout(() => renderCaddie(), 1000); }
                        if (button.matches('.add-new-club')) { showModal('add-club-modal'); }
                        if (button.matches('.delete-club')) { state.clubs.splice(parseInt(button.dataset.index, 10), 1); saveClubs(); renderSettings(); }
                        if (button.closest('.round-type-selector')) { state.scorecard.roundType = parseInt(button.dataset.type, 10); saveScorecard(); updateScorecardView(); }
                        if (button.matches('.finish-round')) { document.getElementById('course-name-input').value = `Round - ${new Date().toLocaleDateString()}`; showModal('save-modal'); }
                        if (button.matches('.delete-round')) { state.roundToDeleteIndex = parseInt(button.dataset.index, 10); const round = state.history[state.roundToDeleteIndex]; document.getElementById('delete-round-text').textContent = `Are you sure you want to delete the round at ${round.courseName}?`; showModal('delete-round-modal'); }
                    }
                });

                document.getElementById('cancel-save').addEventListener('click', () => hideModal('save-modal'));
                document.getElementById('confirm-save').addEventListener('click', () => { const courseName = document.getElementById('course-name-input').value.trim(); if (courseName) { const roundToSave = JSON.parse(JSON.stringify(state.scorecard)); const numHoles = roundToSave.roundType; const totalScore = roundToSave.scores.slice(0, numHoles).reduce((a, b) => a + b, 0); const totalPar = roundToSave.pars.slice(0, numHoles).reduce((a, b) => a + b, 0); const totalPutts = roundToSave.putts.slice(0, numHoles).reduce((a, b) => a + b, 0); state.history.unshift({ courseName, date: new Date().toISOString(), totalScore, toPar: totalScore - totalPar, totalPutts, scorecard: roundToSave }); saveHistory(); state.scorecard = createDefaultScorecard(); saveScorecard(); hideModal('save-modal'); renderHistory(); } });
                document.getElementById('cancel-delete-round').addEventListener('click', () => hideModal('delete-round-modal'));
                document.getElementById('confirm-delete-round').addEventListener('click', () => { if (state.roundToDeleteIndex !== null) { state.history.splice(state.roundToDeleteIndex, 1); saveHistory(); renderHistory(); state.roundToDeleteIndex = null; } hideModal('delete-round-modal'); });
                document.getElementById('cancel-add-club').addEventListener('click', () => hideModal('add-club-modal'));
                document.getElementById('confirm-add-club').addEventListener('click', () => { const name = document.getElementById('new-club-name').value.trim(); const min = parseInt(document.getElementById('new-club-min').value, 10); const max = parseInt(document.getElementById('new-club-max').value, 10); if (name && !isNaN(min) && !isNaN(max) && max >= min) { state.clubs.push({ name, min, max, order: state.clubs.length + 1 }); saveClubs(); document.getElementById('new-club-name').value = ''; document.getElementById('new-club-min').value = ''; document.getElementById('new-club-max').value = ''; hideModal('add-club-modal'); renderSettings(); } else { 
                    // Using a custom modal for alerts would be better, but for simplicity:
                    // alert('Please enter a valid name and range (max >= min).'); 
                    console.error('Please enter a valid name and range (max >= min).');
                } });

                loadData();
                renderCaddie();
            }

            // --- GAMES APP LOGIC ---
            const gameSelectionMenu = document.getElementById('game-selection-menu');
            const gameSelectBtns = document.querySelectorAll('.game-select-btn');
            const gameContainers = document.querySelectorAll('.game-container');
            const backToMenuBtns = document.querySelectorAll('.back-to-menu-btn');
            const matrixCanvas = document.getElementById('matrix-canvas');
            const matrixBackBtn = document.getElementById('matrix-back-btn');

            function showGameSelection() {
                if (activeGameLoop) {
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }
                gameSelectionMenu.style.display = 'flex';
                gameContainers.forEach(c => c.classList.add('hidden'));
                matrixCanvas.classList.remove('fullscreen');
                matrixCanvas.style.display = 'block';
                matrixBackBtn.classList.add('hidden');
                initMatrixRain(); // Start rain for menu background
            }

            function showGame(gameName) {
                if (activeGameLoop) {
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }
                gameSelectionMenu.style.display = 'none';
                matrixCanvas.style.display = 'none'; // Hide matrix background for games
                matrixBackBtn.classList.add('hidden');

                gameContainers.forEach(c => {
                    c.classList.toggle('hidden', c.id !== `${gameName}-container`);
                    c.classList.toggle('flex', c.id === `${gameName}-container`);
                });
                if (gameName === 'breakout-game') {
                    initBreakoutGame();
                } else if (gameName === 'connect-four') {
                    initConnectFourGame();
                }
            }
            
            function showMatrixMode() {
                if (activeGameLoop) { // Ensure previous loop is stopped
                    cancelAnimationFrame(activeGameLoop);
                    activeGameLoop = null;
                }
                gameSelectionMenu.style.display = 'none';
                gameContainers.forEach(c => c.classList.add('hidden'));
                matrixCanvas.style.display = 'block';
                matrixCanvas.classList.add('fullscreen');
                matrixBackBtn.classList.remove('hidden');
                initMatrixRain(); // Start/restart rain
            }

            gameSelectBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const game = btn.dataset.game;
                    if (game === 'breakout') {
                        showGame('breakout-game');
                    } else if (game === 'connect-four') {
                        showGame('connect-four');
                    } else if (game === 'matrix-mode') {
                        showMatrixMode();
                    }
                });
            });
            
            backToMenuBtns.forEach(btn => {
                btn.addEventListener('click', showGameSelection);
            });
            matrixBackBtn.addEventListener('click', showGameSelection);

            // --- MATRIX RAIN INITIALIZATION ---
            function initMatrixRain() {
                const canvas = document.getElementById('matrix-canvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                // The phrase to be spelled out, with spaces.
                const phrase = "BRETT  IS  GAY  ";

                const resizeCanvas = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                const fontSize = 16;
                const columns = Math.floor(canvas.width / fontSize);

                // Each element in rainDrops is now an object tracking its y position and its character index in the phrase.
                const rainDrops = [];
                for(let i = 0; i < columns; i++) {
                    rainDrops[i] = {
                        y: Math.random() * canvas.height, // Start at a random height
                        charIndex: Math.floor(Math.random() * phrase.length) // Start at a random character
                    };
                }

                function drawMatrix() {
                    // Semi-transparent black background for the fading trail effect
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#0F0'; // Classic green color
                    ctx.font = fontSize + 'px monospace';

                    for(let i = 0; i < rainDrops.length; i++) {
                        // Get the correct character from the phrase based on the stream's current index
                        const text = phrase.charAt(rainDrops[i].charIndex);
                        
                        // Only draw the character if it's not a space
                        if (text !== ' ') {
                            ctx.fillText(text, i * fontSize, rainDrops[i].y * fontSize);
                        }
                        
                        // If the stream has gone off-screen, reset it to the top with a new random character index
                        if(rainDrops[i].y * fontSize > canvas.height && Math.random() > 0.975){
                            rainDrops[i].y = 0;
                            rainDrops[i].charIndex = Math.floor(Math.random() * phrase.length);
                        }

                        // Move the stream down for the next frame
                        rainDrops[i].y++;
                        
                        // Move to the next character in the phrase, looping back to the start if necessary
                        rainDrops[i].charIndex = (rainDrops[i].charIndex + 1) % phrase.length;
                    }
                }

                function animateMatrix() {
                    drawMatrix();
                    activeGameLoop = requestAnimationFrame(animateMatrix);
                }
                
                if (activeGameLoop) cancelAnimationFrame(activeGameLoop);
                animateMatrix();
            }

            // --- BREAKOUT GAME INITIALIZATION ---
            function initBreakoutGame() {
                const canvas = document.getElementById('breakoutCanvas');
                const ctx = canvas.getContext('2d');
                const scoreEl = document.getElementById('score');
                const livesEl = document.getElementById('lives');
                const levelEl = document.getElementById('level-display');
                const modal = document.getElementById('modal');
                const modalText = document.getElementById('modal-text');
                const modalSubtitle = document.getElementById('modal-subtitle');
                const startBtn = document.getElementById('start-btn');

                let score = 0, lives = 3, level = 1;
                let gameState = 'start-screen';
                let levelTransitionEndTime = 0;
                const baseWidth = 480, baseHeight = 640;
                let scale = 1;
                let extraLifeDroppedThisLevel = false;
                let lifeLostThisLevel = false;
                let hasUsedExtraLifeChance = false;

                let powerUpState = { isFireballShooter: false, fireballShooterEndTime: 0, nextFireballTime: 0, isBallShooter: false, ballShooterEndTime: 0, nextBallTime: 0, isFastBall: false, fastBallEndTime: 0 };
                let balls = [], bricks = [], powerUps = [], fireballs = [];
                const paddle = { x: 0, y: 0, width: 100, height: 10, color: '#FF00FF', baseWidth: 100 };
                const enemyAIPaddle = { x: 0, y: 0, width: 100, height: 10, color: '#FF4500', active: false };
                const cornerBumperSize = 30;
                const brickInfo = { rowCount: 7, columnCount: 7, width: 55, height: 20, padding: 10, offsetTop: 50 };
                const brickColors = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#8B00FF'];
                const multiHitColors = { 3: '#FFD700', 2: '#C0C0C0', 1: '#CD7F32' };

                let synth, metalSynth, brickHitSynth, brickBreakSynth, megatronSynth, audioInitialized = false;
                let lastSoundTime = 0;

                function playSoundSafe(synth, ...args) {
                    if (!audioInitialized || !synth) return;
                    try {
                        let time = Tone.now();
                        if (time <= lastSoundTime) {
                            time = lastSoundTime + 0.05; // Increased offset
                        }
                        synth.triggerAttackRelease(...args, time);
                        lastSoundTime = time;
                    } catch (e) {
                        // Fail silently if there's a rare scheduling conflict
                    }
                }

                function initAudio() {
                    if (audioInitialized) return;
                    try {
                        if (Tone.context.state !== 'running') { Tone.start(); }
                        synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.2 } }).toDestination();
                        metalSynth = new Tone.MetalSynth({ frequency: 100, envelope: { attack: 0.01, decay: 0.2, release: 0.1 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination();
                        brickHitSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination();
                        brickBreakSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, volume: -12, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination();
                        megatronSynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 14, detune: 0, oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.4 }, modulation: { type: 'sine' }, modulationEnvelope: { attack: 0.05, decay: 0.1, sustain: 0.8, release: 0.4 } }).toDestination();
                        audioInitialized = true;
                        lastSoundTime = 0;
                    } catch (e) { console.error("Could not initialize audio:", e); }
                }

                function resizeAndScale() {
                    const { width, height } = canvas.getBoundingClientRect();
                    canvas.width = width; canvas.height = height;
                    scale = Math.min(width / baseWidth, height / baseHeight);
                    paddle.width = paddle.baseWidth * scale;
                    paddle.height = 10 * scale;
                    enemyAIPaddle.width = 100 * scale;
                    enemyAIPaddle.height = 10 * scale;
                    brickInfo.width = 55 * scale;
                    brickInfo.height = 20 * scale;
                    brickInfo.padding = 10 * scale;
                    brickInfo.offsetTop = 60 * scale;
                    brickInfo.offsetLeft = (canvas.width - (brickInfo.columnCount * (brickInfo.width + brickInfo.padding) - brickInfo.padding)) / 2;
                    paddle.y = canvas.height - 30 * scale;
                    enemyAIPaddle.y = canvas.height / 3;
                }

                function createBricks(currentLevel) {
                    bricks = [];
                    const layouts = [
                        (c, r) => ({ health: 1, color: brickColors[r] }),
                        (c, r) => { if (r >= 3 && c >= r - 3 && c <= 9 - r) { const health = (r === 3 || c === r - 3 || c === 9 - r) ? 2 : 1; return { health, color: health === 2 ? multiHitColors[2] : brickColors[r] }; } return null; },
                        (c, r) => { if ((c + r) % 2 === 0) { const health = (c > 1 && c < 5 && r > 1 && r < 5) ? 3 : 1; return { health, color: health === 3 ? multiHitColors[3] : brickColors[r] }; } return null; },
                        (c, r) => { if (c === 0 || c === 6 || r === 0 || r === 6) return { health: 2, color: multiHitColors[2] }; if (c === 1 || c === 5 || r === 1 || r === 5) return { health: 1, color: brickColors[r] }; if (c > 1 && c < 5 && r > 1 && r < 5) return { health: 3, color: multiHitColors[3] }; return null; },
                        (c, r) => { if (c % 2 === 0) { const health = r < 2 ? 2 : 1; return { health, color: health === 2 ? multiHitColors[2] : brickColors[r] }; } return null; },
                        (c, r) => { if ((r === 1 || r === 2) && (c === 1 || c === 5)) return { health: 2, color: multiHitColors[2] }; if (r === 4 && c > 0 && c < 6) return { health: 1, color: brickColors[1] }; if (r === 5 && (c === 1 || c === 5)) return { health: 1, color: brickColors[1] }; return null; },
                        (c, r) => { if (c === 0 || c === 6 || r === 0) return { health: 3, color: multiHitColors[3] }; if (r > 2 && (c === 2 || c === 4)) return { health: 2, color: multiHitColors[2] }; if (r === 4 && c === 3) return { health: 1, color: brickColors[0] }; return null; },
                        (c, r) => { if ((c === 1 && r === 1) || (c === 5 && r === 1) || (c === 3 && r === 4) || (c === 1 && r === 6) || (c === 5 && r === 6)) return { health: 3, color: multiHitColors[3] }; return null; },
                        (c, r) => { const health = (c + r) % 2 === 0 ? 3 : 1; return { health, color: health === 3 ? multiHitColors[3] : brickColors[r] }; },
                        (c, r) => ({ health: 3, color: multiHitColors[3] })
                    ];
                    const layoutFunc = layouts[Math.min(currentLevel - 1, layouts.length - 1)];
                    for (let c = 0; c < brickInfo.columnCount; c++) {
                        bricks[c] = [];
                        for (let r = 0; r < brickInfo.rowCount; r++) {
                            const brickProps = layoutFunc(c, r);
                            if (brickProps) {
                                const brickX = c * (brickInfo.width + brickInfo.padding) + brickInfo.offsetLeft;
                                const brickY = r * (brickInfo.height + brickInfo.padding) + brickInfo.offsetTop;
                                bricks[c][r] = { x: brickX, y: brickY, status: 1, initialHealth: brickProps.health, ...brickProps };
                            } else {
                                bricks[c][r] = { status: 0 };
                            }
                        }
                    }
                }

                function createBall(x, y, dx, dy, type = 'normal') {
                    let newBall = { x, y, radius: 8 * scale, dx: dx * scale, dy: dy * scale, type, isFast: false };
                    if (powerUpState.isFastBall) {
                        newBall.isFast = true;
                        newBall.dx *= 1.5;
                        newBall.dy *= 1.5;
                    }
                    return newBall;
                }

                function createFireball() {
                    fireballs.push({ x: paddle.x + paddle.width / 2, y: paddle.y, radius: 6 * scale, dy: -8 * scale, color: '#FF4500' });
                    playSoundSafe(synth, "A5", "16n");
                }

                function shootExtraBall() {
                    balls.push(createBall(paddle.x + paddle.width / 2, paddle.y, (Math.random() - 0.5) * 4, -4));
                    playSoundSafe(synth, "G5", "16n");
                }

                function createPowerUp(x, y) {
                    let type;
                    const symbols = { 'enlarge': 'E', 'super-ball': 'S', 'multi-ball': 'M', 'extra-life': '+', 'fast-ball': 'F', 'fireball-shooter': 'C', 'ball-shooter': 'B' };
                    if (!extraLifeDroppedThisLevel && Math.random() < 0.1) {
                        type = 'extra-life';
                        extraLifeDroppedThisLevel = true;
                    } else {
                        const rand = Math.random();
                        if (rand < 0.30) { type = 'multi-ball'; }
                        else {
                            const remainingTypes = ['enlarge', 'super-ball', 'fast-ball', 'fireball-shooter', 'ball-shooter'];
                            type = remainingTypes[Math.floor(Math.random() * remainingTypes.length)];
                        }
                    }
                    if (type) {
                        powerUps.push({ x, y, type, symbol: symbols[type], size: 15 * scale, dy: 2 * scale });
                    }
                }

                function draw() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBricks();
                    drawPaddle();
                    if (enemyAIPaddle.active) drawEnemyAIPaddle();
                    drawPowerUps();
                    drawBalls();
                    drawFireballs();
                    drawCornerBumpers();
                }

                function drawCornerBumpers() { const size = cornerBumperSize * scale; ctx.fillStyle = '#444'; ctx.beginPath(); ctx.moveTo(0, canvas.height - size); ctx.lineTo(size, canvas.height); ctx.lineTo(0, canvas.height); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(canvas.width, canvas.height - size); ctx.lineTo(canvas.width - size, canvas.height); ctx.lineTo(canvas.width, canvas.height); ctx.closePath(); ctx.fill(); }
                function drawBalls() { balls.forEach(ball => { ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fillStyle = ball.type === 'super' ? '#FFA500' : '#00FFFF'; ctx.fill(); ctx.closePath(); }); }
                function drawFireballs() { fireballs.forEach(fb => { ctx.beginPath(); ctx.arc(fb.x, fb.y, fb.radius, 0, Math.PI * 2); ctx.fillStyle = fb.color; ctx.fill(); ctx.closePath(); }); }
                function drawPaddle() { ctx.beginPath(); ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height); ctx.fillStyle = paddle.color; ctx.fill(); ctx.closePath(); }
                function drawEnemyAIPaddle() { ctx.beginPath(); ctx.rect(enemyAIPaddle.x, enemyAIPaddle.y, enemyAIPaddle.width, enemyAIPaddle.height); ctx.fillStyle = enemyAIPaddle.color; ctx.fill(); ctx.closePath(); }
                function drawBricks() { bricks.flat().forEach(b => { if (b.status === 1) { ctx.beginPath(); ctx.rect(b.x, b.y, brickInfo.width, brickInfo.height); ctx.fillStyle = b.health > 1 ? multiHitColors[b.health] : b.color; ctx.fill(); ctx.closePath(); } }); }
                function drawPowerUps() { powerUps.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fillStyle = '#FF00FF'; ctx.fill(); ctx.fillStyle = '#FFFFFF'; ctx.font = `bold ${p.size}px 'Press Start 2P'`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(p.symbol, p.x, p.y); ctx.closePath(); }); }

                function update() {
                    let powerUpsToActivate = [];
                    moveBalls();
                    updateFireballs();
                    powerUpsToActivate = updatePowerUps();
                    powerUpsToActivate.forEach(type => activatePowerUp(type));
                    updateActivePowerUps();
                    if (enemyAIPaddle.active) updateEnemyAIPaddle();
                }

                function updateEnemyAIPaddle() { let targetBall = balls.reduce((lowest, ball) => ball.y > lowest.y ? ball : lowest, {y: -Infinity}); if(targetBall.y !== -Infinity) { enemyAIPaddle.x += (targetBall.x - (enemyAIPaddle.x + enemyAIPaddle.width / 2)) * 0.12; } if (enemyAIPaddle.x < 0) enemyAIPaddle.x = 0; if (enemyAIPaddle.x + enemyAIPaddle.width > canvas.width) enemyAIPaddle.x = canvas.width - enemyAIPaddle.width; }
                function moveBalls() {
                    const collisions = [];
                    balls.forEach(ball => {
                        ball.x += ball.dx;
                        ball.y += ball.dy;
                        if (ball.x > canvas.width - ball.radius || ball.x < ball.radius) { ball.dx = -ball.dx; }
                        if (ball.y < ball.radius) { ball.dy = -ball.dy; }
                        const size = cornerBumperSize * scale;
                        if (ball.y > canvas.height - size) {
                            if (ball.x < size && ball.dy > 0) { ball.dx = Math.abs(ball.dy); ball.dy = -Math.abs(ball.dx); playSoundSafe(synth, "E4", "8n"); }
                            if (ball.x > canvas.width - size && ball.dy > 0) { ball.dx = -Math.abs(ball.dy); ball.dy = -Math.abs(ball.dx); playSoundSafe(synth, "E4", "8n"); }
                        }
                        if (enemyAIPaddle.active && ball.y < enemyAIPaddle.y + enemyAIPaddle.height + ball.radius && ball.dy < 0) { if (ball.x > enemyAIPaddle.x && ball.x < enemyAIPaddle.x + enemyAIPaddle.width) { ball.dy = -ball.dy; playSoundSafe(synth, "G3", "8n"); } }
                        if (ball.y > paddle.y - ball.radius && ball.y < paddle.y + paddle.height && ball.x > paddle.x && ball.x < paddle.x + paddle.width) { let collidePoint = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2); let currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy); let angle; if (Math.abs(collidePoint) < 0.1) { angle = (collidePoint >= 0 ? 1 : -1) * (Math.PI / 8); } else { angle = collidePoint * (Math.PI / 3); } ball.dx = currentSpeed * Math.sin(angle); ball.dy = -currentSpeed * Math.cos(angle); ball.y += ball.dy; playSoundSafe(synth, "C4", "8n"); }
                        const hitBrick = brickCollisionDetection(ball);
                        if (hitBrick) { collisions.push({ ball, brick: hitBrick }); }
                    });
                    collisions.forEach(({ ball, brick }) => resolveBrickCollision(ball, brick));
                    const initialBallCount = balls.length;
                    balls = balls.filter(ball => ball.y < canvas.height);
                    if (balls.length < initialBallCount && balls.length > 0) playSoundSafe(synth, "C3", "8n");
                    if (balls.length === 0 && gameState === 'playing') {
                        lives--;
                        lifeLostThisLevel = true;
                        playSoundSafe(metalSynth, "C2", "4n");
                        if (lives <= 0) gameOver(); else resetBallAndPaddle();
                    }
                }

                function updateFireballs() { fireballs.forEach((fb, index) => { fb.y += fb.dy; if (fb.y < 0) { fireballs.splice(index, 1); return; } for (const b of bricks.flat()) { if (b.status === 1 && fb.x > b.x && fb.x < b.x + brickInfo.width && fb.y > b.y && fb.y < b.y + brickInfo.height) { fireballs.splice(index, 1); handleBrickHit(b); return; } } }); }
                function handleBrickHit(b) { if (b.status !== 1) return; b.health--; score += 10; if (b.health <= 0) { playSoundSafe(brickBreakSynth, "8n"); b.status = 0; score += 20; const isSpecialLevel = level >= 5 && level <= 8; const enemyChance = isSpecialLevel ? 0.10 : 0.03; let powerUpChance; if (b.initialHealth > 1) { powerUpChance = 0.80; } else { powerUpChance = isSpecialLevel ? 0.40 : 0.25; } if (Math.random() < enemyChance && !enemyAIPaddle.active) { activateEnemyAI(); } else if (Math.random() < powerUpChance) { createPowerUp(b.x + brickInfo.width / 2, b.y + brickInfo.height / 2); } } else { playSoundSafe(brickHitSynth, "C2", "8n"); } checkWin(); }
                function brickCollisionDetection(ball) { for (const b of bricks.flat()) { if (b.status !== 1) continue; const closestX = Math.max(b.x, Math.min(ball.x, b.x + brickInfo.width)); const closestY = Math.max(b.y, Math.min(ball.y, b.y + brickInfo.height)); const distanceX = ball.x - closestX; const distanceY = ball.y - closestY; const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); if (distanceSquared < (ball.radius * ball.radius)) { return b; } } return null; }
                function resolveBrickCollision(ball, b) { if (b.status !== 1) return; if (ball.type !== 'super') { const closestX = Math.max(b.x, Math.min(ball.x, b.x + brickInfo.width)); const closestY = Math.max(b.y, Math.min(ball.y, b.y + brickInfo.height)); const distanceX = ball.x - closestX; const distanceY = ball.y - closestY; const overlapX = ball.radius - Math.abs(distanceX); const overlapY = ball.radius - Math.abs(distanceY); if (overlapX > overlapY) { ball.dy = -ball.dy; ball.y += ball.dy > 0 ? overlapY : -overlapY; } else { ball.dx = -ball.dx; ball.x += ball.dx > 0 ? overlapX : -overlapX; } } handleBrickHit(b); }
                function updatePowerUps() { const collectedPowerUps = []; powerUps = powerUps.filter(p => { p.y += p.dy; if (p.y > paddle.y && p.x > paddle.x && p.x < paddle.x + paddle.width) { collectedPowerUps.push(p.type); return false; } return p.y < canvas.height; }); return collectedPowerUps; }
                function updateActivePowerUps() { const now = Date.now(); if (powerUpState.isFireballShooter) { if (now > powerUpState.fireballShooterEndTime) { powerUpState.isFireballShooter = false; } else if (now > powerUpState.nextFireballTime) { createFireball(); powerUpState.nextFireballTime = now + 1000; } } if (powerUpState.isBallShooter) { if (now > powerUpState.ballShooterEndTime) { powerUpState.isBallShooter = false; } else if (now > powerUpState.nextBallTime) { shootExtraBall(); powerUpState.nextBallTime = now + 2000; } } if (powerUpState.isFastBall && now > powerUpState.fastBallEndTime) { powerUpState.isFastBall = false; balls.forEach(ball => { if (ball.isFast) { ball.dx /= 1.5; ball.dy /= 1.5; ball.isFast = false; } }); } }
                function activatePowerUp(type) { playSoundSafe(synth, "C6", "8n"); if (type === 'enlarge') { paddle.baseWidth = 150; resizeAndScale(); setTimeout(() => { paddle.baseWidth = 100; resizeAndScale(); }, 10000); } else if (type === 'super-ball') { balls.forEach(b => b.type = 'super'); setTimeout(() => balls.forEach(b => b.type = 'normal'), 10000); } else if (type === 'multi-ball') { const originalBalls = [...balls]; originalBalls.forEach(b => { balls.push(createBall(b.x, b.y, b.dx + 1, b.dy)); balls.push(createBall(b.x, b.y, b.dx - 1, b.dy)); }); } else if (type === 'extra-life') { lives++; } else if (type === 'fast-ball') { if (!powerUpState.isFastBall) { balls.forEach(ball => { ball.dx *= 1.5; ball.dy *= 1.5; ball.isFast = true; }); } powerUpState.isFastBall = true; powerUpState.fastBallEndTime = Date.now() + 8000; } else if (type === 'fireball-shooter') { powerUpState.isFireballShooter = true; powerUpState.fireballShooterEndTime = Date.now() + 10000; powerUpState.nextFireballTime = Date.now(); } else if (type === 'ball-shooter') { powerUpState.isBallShooter = true; powerUpState.ballShooterEndTime = Date.now() + 10000; powerUpState.nextBallTime = Date.now(); } }
                function activateEnemyAI() { enemyAIPaddle.active = true; if(audioInitialized) { const now = Tone.now(); megatronSynth.triggerAttackRelease("G2", "4n", now); megatronSynth.triggerAttackRelease("C3", "4n", now + 0.3); megatronSynth.triggerAttackRelease("F2", "2n", now + 0.6); } setTimeout(() => { enemyAIPaddle.active = false; }, 10000); }

                function checkWin() { if (bricks.flat().every(b => b.status === 0)) { if (!lifeLostThisLevel) { lives++; } if (level === 10) { winGame(); return; } gameState = 'level-transition'; level++; powerUps = []; fireballs = []; powerUpState.isFireballShooter = false; powerUpState.isBallShooter = false; powerUpState.isFastBall = false; playSoundSafe(synth, "G5", "2n"); levelTransitionEndTime = Date.now() + 2500; } }
                function startNextLevel() { extraLifeDroppedThisLevel = false; lifeLostThisLevel = false; createBricks(level); resetBallAndPaddle(); }
                function resetBallAndPaddle() { balls = [createBall(canvas.width / 2, canvas.height - 50 * scale, 4 * (Math.random() > 0.5 ? 1 : -1), -4)]; paddle.x = (canvas.width - paddle.width) / 2; }
                function resetGame() { score = 0; lives = 3; level = 1; powerUps = []; fireballs = []; powerUpState = { isFireballShooter: false, fireballShooterEndTime: 0, nextFireballTime: 0, isBallShooter: false, ballShooterEndTime: 0, nextBallTime: 0, isFastBall: false, fastBallEndTime: 0 }; enemyAIPaddle.active = false; extraLifeDroppedThisLevel = false; hasUsedExtraLifeChance = false; lifeLostThisLevel = false; resizeAndScale(); createBricks(level); resetBallAndPaddle(); }
                function gameOver() { if (!hasUsedExtraLifeChance) { gameState = 'extra-life-prompt'; hasUsedExtraLifeChance = true; } else { gameState = 'game-over'; } }
                function winGame() { gameState = 'game-won'; }
                function startGame() { initAudio(); resetGame(); gameState = 'playing'; }

                function loop() {
                    if (gameState === 'playing') { update(); } 
                    else if (gameState === 'level-transition') { if (Date.now() > levelTransitionEndTime) { startNextLevel(); gameState = 'playing'; } }
                    draw();
                    updateUI();
                    activeGameLoop = requestAnimationFrame(loop);
                }

                function updateUI() { scoreEl.textContent = `SCORE: ${score}`; livesEl.textContent = `LIVES: ${lives}`; levelEl.textContent = `LEVEL: ${level}`; if (gameState === 'start-screen' || gameState === 'game-over') { modal.style.display = 'block'; startBtn.style.display = 'block'; modalText.textContent = gameState === 'start-screen' ? 'BREAKOUT' : 'GAME OVER'; modalSubtitle.textContent = gameState === 'start-screen' ? 'Deluxe Edition' : `Final Score: ${score}`; startBtn.textContent = gameState === 'start-screen' ? 'START GAME' : 'RESTART'; } else if (gameState === 'extra-life-prompt') { modal.style.display = 'block'; startBtn.style.display = 'block'; modalText.textContent = "You're out of lives..."; modalSubtitle.textContent = "But you can have one more."; startBtn.textContent = "Admit you are a bitch"; } else if (gameState === 'game-won') { modal.style.display = 'block'; startBtn.style.display = 'block'; modalText.textContent = "Congratu-Fucking-lations"; modalSubtitle.textContent = "You won!!!"; startBtn.textContent = "Play Again?"; } else if (gameState === 'level-transition') { modal.style.display = 'block'; startBtn.style.display = 'none'; modalText.textContent = `LEVEL ${level}`; modalSubtitle.textContent = "Get Ready!"; } else { modal.style.display = 'none'; } }
                function movePaddle(x) { paddle.x = x - paddle.width / 2; if (paddle.x < 0) { paddle.x = 0; } if (paddle.x + paddle.width > canvas.width) { paddle.x = canvas.width - paddle.width; } }
                function handleMove(e) { if (e.type.includes('touch')) { e.preventDefault(); } const rect = canvas.getBoundingClientRect(); const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX; if (clientX === undefined) return; movePaddle(clientX - rect.left); }

                canvas.addEventListener('mousemove', handleMove);
                canvas.addEventListener('touchmove', handleMove, { passive: false });
                canvas.addEventListener('touchstart', handleMove, { passive: false });
                startBtn.addEventListener('click', () => { if (gameState === 'start-screen' || gameState === 'game-over' || gameState === 'game-won') { startGame(); } else if (gameState === 'extra-life-prompt') { lives = 1; resetBallAndPaddle(); gameState = 'playing'; } });
                window.addEventListener('resize', () => { resizeAndScale(); draw(); updateUI(); });
                
                resizeAndScale();
                loop();
            }

            // --- CONNECT FOUR GAME INITIALIZATION ---
            function initConnectFourGame() {
                const boardElement = document.getElementById('board');
                const columnSelectorsElement = document.getElementById('column-selectors');
                const statusElement = document.getElementById('status');
                const newGameButton = document.getElementById('newGame');
                const winnerModal = document.getElementById('winnerModal');
                const winnerModalContent = winnerModal.querySelector('div');
                const winnerText = document.getElementById('winnerText');
                const playAgainButton = document.getElementById('playAgain');

                const ROWS = 6;
                const COLS = 7;
                const HUMAN_PLAYER = 1;
                const AI_PLAYER = 2;
                let board = [];
                let currentPlayer = HUMAN_PLAYER;
                let gameOver = false;

                function createBoard() {
                    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
                    gameOver = false;
                    currentPlayer = HUMAN_PLAYER;
                    boardElement.innerHTML = '';
                    columnSelectorsElement.innerHTML = '';
                    for (let row = 0; row < ROWS; row++) {
                        for (let col = 0; col < COLS; col++) {
                            const cell = document.createElement('div');
                            cell.classList.add('cell');
                            cell.dataset.row = row;
                            cell.dataset.col = col;
                            boardElement.appendChild(cell);
                        }
                    }
                    for (let col = 0; col < COLS; col++) {
                        const column = document.createElement('div');
                        column.classList.add('column');
                        column.dataset.col = col;
                        column.addEventListener('click', () => handleColumnClick(col));
                        columnSelectorsElement.appendChild(column);
                    }
                    updateStatus();
                    toggleColumnSelectors(true);
                }

                function handleColumnClick(col) {
                    if (gameOver || currentPlayer !== HUMAN_PLAYER) return;
                    const row = findAvailableRow(board, col);
                    if (row === -1) return;
                    dropPiece(row, col, HUMAN_PLAYER);
                    if (gameOver) return;
                    currentPlayer = AI_PLAYER;
                    updateStatus();
                    toggleColumnSelectors(false);
                    setTimeout(aiMove, 500);
                }

                function aiMove() {
                    statusElement.textContent = "Computer is thinking...";
                    const { col } = minimax(board, 7, -Infinity, Infinity, true);
                    if (col === null) {
                        gameOver = true;
                        showWinner("It's a Draw!");
                        return;
                    }
                    const row = findAvailableRow(board, col);
                    dropPiece(row, col, AI_PLAYER);
                    if (gameOver) return;
                    currentPlayer = HUMAN_PLAYER;
                    updateStatus();
                    toggleColumnSelectors(true);
                }

                function findAvailableRow(b, col) { for (let row = ROWS - 1; row >= 0; row--) { if (b[row][col] === 0) return row; } return -1; }
                function dropPiece(row, col, player) {
                    board[row][col] = player;
                    const piece = document.createElement('div');
                    piece.classList.add('piece', `player${player}`);
                    const targetCell = document.querySelector(`#connect-four-container .cell[data-row='${row}'][data-col='${col}']`);
                    targetCell.appendChild(piece);
                    if (checkForWin(board, player)) {
                        gameOver = true;
                        if (player === HUMAN_PLAYER) { showWinner("You won! But I bet you can't do it again."); } 
                        else { showWinner("The Computer Wins!"); }
                        highlightWinningCells(board, player);
                    } else if (isBoardFull(board)) {
                        gameOver = true;
                        showWinner("It's a Draw!");
                    }
                }

                function updateStatus() { if (gameOver) return; if (currentPlayer === HUMAN_PLAYER) { statusElement.textContent = "Your Turn (Red)"; statusElement.style.color = '#ef4444'; } else { statusElement.textContent = "Computer's Turn (Yellow)"; statusElement.style.color = '#facc15'; } }
                function toggleColumnSelectors(enabled) { columnSelectorsElement.style.pointerEvents = enabled ? 'auto' : 'none'; }
                function showWinner(message) { statusElement.textContent = message; winnerText.textContent = message; winnerModal.classList.remove('hidden'); winnerModal.classList.add('flex'); setTimeout(() => { winnerModalContent.style.transform = 'scale(1)'; winnerModalContent.style.opacity = '1'; }, 50); }
                function isBoardFull(b) { return b[0].every(cell => cell !== 0); }
                function checkForWin(b, player) { for (let r = 0; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r][c+1] === player && b[r][c+2] === player && b[r][c+3] === player) return true; } } for (let c = 0; c < COLS; c++) { for (let r = 0; r <= ROWS - 4; r++) { if (b[r][c] === player && b[r+1][c] === player && b[r+2][c] === player && b[r+3][c] === player) return true; } } for (let r = 0; r <= ROWS - 4; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r+1][c+1] === player && b[r+2][c+2] === player && b[r+3][c+3] === player) return true; } } for (let r = 3; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r-1][c+1] === player && b[r-2][c+2] === player && b[r-3][c+3] === player) return true; } } return false; }
                function highlightWinningCells(b, player) {
                    let winningLine = [];
                    const findLine = () => {
                        for (let r = 0; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r][c+1] === player && b[r][c+2] === player && b[r][c+3] === player) return [{r,c},{r,c:c+1},{r,c:c+2},{r,c:c+3}]; } }
                        for (let c = 0; c < COLS; c++) { for (let r = 0; r <= ROWS - 4; r++) { if (b[r][c] === player && b[r+1][c] === player && b[r+2][c] === player && b[r+3][c] === player) return [{r,c},{r:r+1,c},{r:r+2,c},{r:r+3,c}]; } }
                        for (let r = 0; r <= ROWS - 4; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r+1][c+1] === player && b[r+2][c+2] === player && b[r+3][c+3] === player) return [{r,c},{r:r+1,c:c+1},{r:r+2,c:c+2},{r:r+3,c:c+3}]; } }
                        for (let r = 3; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { if (b[r][c] === player && b[r-1][c+1] === player && b[r-2][c+2] === player && b[r-3][c+3] === player) return [{r,c},{r:r-1,c:c+1},{r:r-2,c:c+2},{r:r-3,c:c+3}]; } }
                        return [];
                    };
                    winningLine = findLine();
                    winningLine.forEach(pos => {
                        const cellElement = document.querySelector(`#connect-four-container .cell[data-row='${pos.r}'][data-col='${pos.c}']`);
                        if (cellElement) cellElement.classList.add('winning-cell');
                    });
                }
                function scorePosition(b, player) {
                    let score = 0;
                    const centerArray = b.map(row => row[Math.floor(COLS / 2)]);
                    score += centerArray.filter(p => p === player).length * 6;
                    const scoreLine = (line, p) => {
                        let s = 0;
                        const opponentPlayer = p === AI_PLAYER ? HUMAN_PLAYER : AI_PLAYER;
                        const playerCount = line.filter(val => val === p).length;
                        const emptyCount = line.filter(val => val === 0).length;
                        const opponentCount = line.filter(val => val === opponentPlayer).length;
                        if (playerCount === 4) s += 1000000;
                        else if (playerCount === 3 && emptyCount === 1) s += 5000;
                        else if (playerCount === 2 && emptyCount === 2) s += 50;
                        if (opponentCount === 3 && emptyCount === 1) s -= 10000;
                        return s;
                    };
                    for (let r = 0; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { score += scoreLine(b[r].slice(c, c + 4), player); } }
                    for (let c = 0; c < COLS; c++) { for (let r = 0; r <= ROWS - 4; r++) { score += scoreLine([b[r][c], b[r+1][c], b[r+2][c], b[r+3][c]], player); } }
                    for (let r = 0; r <= ROWS - 4; r++) { for (let c = 0; c <= COLS - 4; c++) { score += scoreLine([b[r][c], b[r+1][c+1], b[r+2][c+2], b[r+3][c+3]], player); } }
                    for (let r = 3; r < ROWS; r++) { for (let c = 0; c <= COLS - 4; c++) { score += scoreLine([b[r][c], b[r-1][c+1], b[r-2][c+2], b[r-3][c+3]], player); } }
                    return score;
                }
                function getValidLocations(b) { return [...Array(COLS).keys()].filter(c => b[0][c] === 0); }
                function minimax(b, depth, alpha, beta, maximizingPlayer) {
                    const isTerminal = checkForWin(b, HUMAN_PLAYER) || checkForWin(b, AI_PLAYER) || isBoardFull(b);
                    if (depth === 0 || isTerminal) {
                        if (isTerminal) {
                            if (checkForWin(b, AI_PLAYER)) return { col: null, score: 10000000 };
                            if (checkForWin(b, HUMAN_PLAYER)) return { col: null, score: -10000000 };
                            return { col: null, score: 0 };
                        }
                        return { col: null, score: scorePosition(b, AI_PLAYER) };
                    }
                    const validLocations = getValidLocations(b);
                    const columnOrder = [3, 4, 2, 5, 1, 6, 0];
                    const prioritizedLocations = columnOrder.filter(col => validLocations.includes(col));
                    if (maximizingPlayer) {
                        let value = -Infinity;
                        let column = prioritizedLocations[0];
                        for (const col of prioritizedLocations) {
                            let b_copy = b.map(r => [...r]);
                            const row = findAvailableRow(b_copy, col);
                            b_copy[row][col] = AI_PLAYER;
                            let new_score = minimax(b_copy, depth - 1, alpha, beta, false).score;
                            if (new_score > value) {
                                value = new_score;
                                column = col;
                            }
                            alpha = Math.max(alpha, value);
                            if (alpha >= beta) break;
                        }
                        return { col: column, score: value };
                    } else { // Minimizing player
                        let value = Infinity;
                        let column = prioritizedLocations[0];
                        for (const col of prioritizedLocations) {
                            let b_copy = b.map(r => [...r]);
                            const row = findAvailableRow(b_copy, col);
                            b_copy[row][col] = HUMAN_PLAYER;
                            let new_score = minimax(b_copy, depth - 1, alpha, beta, true).score;
                            if (new_score < value) {
                                value = new_score;
                                column = col;
                            }
                            beta = Math.min(beta, value);
                            if (alpha >= beta) break;
                        }
                        return { col: column, score: value };
                    }
                }
                function resetGame() {
                    winnerModal.classList.remove('flex');
                    winnerModal.classList.add('hidden');
                    createBoard();
                }
                newGameButton.addEventListener('click', createBoard);
                playAgainButton.addEventListener('click', resetGame);
                createBoard();
            }

            // --- INITIALIZE ALL APPS ---
            initFeedApp();
            initGolfApp();
            showPage('feed-page'); // Show the feed page by default
        });
    </script>
</body>
</html>
